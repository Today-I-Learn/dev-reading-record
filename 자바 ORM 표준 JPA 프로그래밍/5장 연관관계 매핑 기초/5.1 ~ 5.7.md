# 5장 연관관계 매핑 기초

엔티티들은 대부분 다른 엔티티와 연관관계가 존재한다. 객체는 참조를 사용해 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다.

이 둘은 완전히 다른 특징을 갖기 때문에 객체 관계 매핑에서 가장 어려운 부분이 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.

연관관계 매핑을 이해하기 위한 핵심 키워드는 `방향`, `다중성` 그리고 `연관관계의 주인`이다.

## 단방향 연관관계

#### 객체 연관관계
- 객체는 단방향 관계다.
- 객체의 필드로 다른 객체와 연관관계를 맺는다.

#### 테이블 연관관계
- 양방향 관계이다.
- 테이블은 외래 키로 다른 테이블과 연관관계를 맺는다.
- 두 테이블의 외래 키를 통해서 서로 조인할 수 있다.

#### 객체 연관관계와 테이블 연관관계의 가장 큰 차이
참조를 통한 연관관계는 언제나 단방향이다.
객체간에 연관관계를 양뱡항으로 만들기 위해서는 반대쪽에도 필드를 추가해 참조를 보관해야 한다.
양쪽에서 서로 참조하는 것을 양방향 연관관계라고 하지만 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개인 것이다.
반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.

```java
// 단방향 연관관계
class A{
    B b;
}
class B{}

//양방향 연관관계
class A{
    B b;
}

class B{
    A a;
}
```

객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 `객체 그래프 탐색`이라 한다.

#### 객체 관계 매핑

```java
// 연관관계 매핑
@ManyToOne
@JoinColumn(name="TEAM_ID")
private Team team;
```

- @ManyToOne
    - 다대일(N:1) 관계라는 매핑 정보
    - 연관관계를 매핑할 때 다중성을 나타내는 어노테이션은 필수로 사용해야한다.
    - 다대일과 비슷한 일대일(@OneToOne) 관계도 존재한다.
    단방향 관계를 매핑할 때 둘 중 어떤 것을 사용해야 할지는 반대편 관계에 달려있다.
    반대편이 일대다 관계면 다대일을 사용하고 반대편이 일대일 관계면 일대일을 사용하면 된다.
    
- @JoinColumn(name="TEAM_ID")
    - 조인 칼럼은 외래 키를 매핑할 때 사용
    - name 속성에 매핑할 외래 키 이름을 지정
    - 해당 어노테이션을 생략하는 경우 외래 키를 찾을 때 기본 전략을 사용
    (기본 전략: 필드명 + _ + 참조하는 테이블의 칼럼명)
    
## 연관관계 사용

#### 저장

JPA 에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

```java
member1.setTeam(team1); // 연관관계 설정 member1 -> team1
em.persist(member1); //저장
```

JPA 는 참조한 팀의 식별자를 외래 키로 사용해서 적절한 등록 쿼리를 생성하게 된다.

#### 조회

연관관계가 있는 엔티티를 조회하는 방법은 객체 그래프 탐색, 객체지향 쿼리 사용(JPQL)로 크게 2가지다.

```java
Team team = member.getTeam(); //객체 그래프 탐색
```

SQL 은 연관된 테이블을 조인해서 검색조건을 사용하면 된다. JPQL 역시 문법은 약간 다르지만 조인을 지원한다.

```java
String jpql = "select m from Member m join m.team t where t.name=:teamName";
```

JPQL 의 `from Member m join m.team t` 부분을 보면 회원이 팀과 관계를 가지고 있는 `m.team`을 통해서 `Member`와 `Team`을 조인한다.

실행된 SQL 과 JPQL 을 비교하면 JPQL 은 객체를 대상으로 하고 SQL 보다 간결하다.

#### 수정

수정은 em.update() 같은 메소드가 없기 때문에 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다.

연관관계를 수정할 때도 참조하는 대상을 변경하면 나머지는 JPA 가 자동으로 처리한다.

#### 삭제

- 연관관계 삭제

연관관계를 null 로 설정하며 기존 연관관계를 제거할 수 있다.

```java
member1.setTeam(null); //연관관계 제거
```

- 연관된 엔티티 삭제

연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해 데이터베이스에서 오류가 발생한다.

```java
member1.setTeam(null); //연관관계 제거
member2.setTeam(null); //연관관계 제거
em.remvoe(team);
```

(참고) 외래 키 제약조건

외래 키 제약조건은 두 테이블 사이의 관계를 선언함으로써 데이터의 무결성을 보장해 주는 역할을 한다.

외래키 관계를 설정하면 하나의 테이블이 다른 테이블에 의존하게 된다.

외래 키 테이블이 참조하는 테이블이 열은 반드시 primary key 이거나 unique 제약조건이 설정되어 있어야한다.

## 양방향 연관관계

회원과 팀이 있을때, 회원과 팀은 다대일 관계하고 하자, 그럼 반대로 팀에서 회원은 일대다 관계다.

일대다 관계는 여러건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야한다. 팀은 Team.members 를 List 컬렉션으로 추가했다.

JPA 는 List, Set, Map 과 같은 다양한 컬렉션을 지원하지만 데이터베이스 테이블은 외래 키 하나로 양방향 조회가 가능하기 때문에 처음부터 양방향 관계이다.

```java
@OneToMany(mappedBt = "team")
private List<Member> members = new ArrayList<>();
``` 

mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다.

## 연관관계의 주인

테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다. 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하지만 양방향으로 매핑하면 `회원 -> 팀` , `팀 -> 화원` 처럼 두곳에서 서로를 참조한다. 따라서 객체의 연관관계를 관리하는 포인트가 2곳으로 늘어나게 되고 객체의 참조는 둘인데 외래 키는 하나이기 때문에 둘 사이에 차이가 발생한다.
이러한 차이로 인해 JPA 에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인이라고 한다.

양방향 연관관계 매핑시 두 연관관계 중 하나를 주인으로 정해야하고, 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제) 할 수 있다.
주인이 아닌쪽은 읽기만 가능하다.
 
 - 주인은 mappedBy 속성을 사용하지 않는다.
 - 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.
 
연관관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이라고 생각하면 된다.
책의 예시에서 회원테이블에 있는 `TEAM_ID` 외래 키를 관리할 관리자로 팀 엔티티에 있는 `Team.members` 를 선택하게 된다면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다.
`Team.members`는 `TEAM` 엔티티에 존재하고 해당 엔티티는 `TEAM` 테이블에 매핑되어 있는데 외래 키는 다른 테이블에 존재하기 때문이다.

따라서 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다. 예시에서는 회원 테이블이 외래 키를 갖고 있기 떄문에 `Memebet.team`이 주인이 된다.

데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 다 쪽인 `@ManyToOne`은 항상 연관관계의 주인이 되기 때문에 mappedBy 속성을 설정할 수 없고, 해당 속성이 존재하지 않는다.

## 양뱡향 연관관계 저장

양방향 연관관계는 연관관계의 주인이 외래 키를 관리한다. 따라서 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다.

따라서 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않고 데이터베이스에 저장할 때 무시된다.

## 양방향 연관관계의 주의점

양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌곳에 값을 입력하는 경우이다.

연관관계의 주인만이 외래 키를 관리할 수 있기 때문에 값이 정상적으로 저장되지 않는다면 가장 우선적으로 의심해봐야한다.

주인에만 값을 저장하고 아닌곳에는 저장을 하지 않아도 되지만 사실 객체 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전한 방법이다.

만일 JPA 를 사용하지 않는 순수한 객체 상태에서는 양쪽 모두 값이 입력되지 않은 경우 문제가 발생할 수 있기 때문이다.

항상 양쪽에 값을 저장해 주기 위해는 각각 메소드를 호출해야하는데 이런 경우 실수를 방지하기 위해 `연관관계 편의 메소드`를 만들어 사용한다.

```java
public class Member{
    private Team team;
    
    //연관관계 편의 메소드
    public void setTeam(Team team){
        
        //기존 팀과 관계를 제거
        if(this.team != null){
            this.team.getMembers().remove(this);
        }
        this.team = team;
        team.getMembers().add(this);
    }
    ...
}
```

위의 연관관계 편의 메소드를 통해 한번에 양방향 관계를 설정할 수 있고 `if(this.team != null)` 해당 조건을 통해 연관관계가 변경될 때 기존에 설정되어 있던 연관관계를 삭제해 줄 수 있다.

기존에 설정되어 있는 연관관계를 제거하지 않아도 외래 키를 변경하는데에는 문제가 없다. 연관관계의 주인의 참조를 변경했기 때문에 주인이 아닌쪽도 정상적으로 반영되기 때문이다.

이후 새로운 영속성 컨텍스트에서 관계를 조회하더라도 이전 관계는 끊어져 있으므로 조회되지 않는다.

하지만 관계를 변경한 후 영속성 컨텍스트가 살아있는 상태에서 주인이 아닌쪽에서 관계를 호출하게 되면 변경 전의 관계가 반환되게 된다. 따라서 `if(this.team != null)` 조건을 통해 항상 이전 관계를 제거하는 로직이 필요하다.

## 정리

연관관계가 하나인 단방향 매핑은 언제나 연관관계의 주인이라는 점이며 양방향은 여기에 주인이 아닌 연관관계를 하나 추가했을 뿐이다.

결국 단방향과 비교해서 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.

- 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 단방향을 양방향으로 만들면 반대 방향으로 객체 그래프 탐색 기능이 추가된다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다.

연관관계의 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 안된다.