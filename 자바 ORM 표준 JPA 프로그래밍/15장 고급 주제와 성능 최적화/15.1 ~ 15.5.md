# 15장 고급 주제와 성능 최적화

JPA의 깊이 있는 고급 주제들과 JPA의 성능을 최적화하는 다양한 방안을 알아보자

## 15.1 예외처리

### JPA 표준 예외 정리

JPA 표준 예외들은 `javax.persistence.PersistenceException`의 자식 클래스이며 이 예외 클래스는 `RuntimeException` 의 자식이다.

JPA 표준 예외는 크게 2가지로 나눌 수 있다.

- 트랜잭션 롤백을 표시하는 예외
- 트랜잭션 롤백을 표시하지 않는 예외

트랜잭션 롤백을 표시하는 예외는 심각한 예외이므로 복구해선 안된다. 반면에 트랜잭션 롤백을 표시하지 않는 예외는 심각한 예외가 아니기 때문에 개발자가 트랜잭션을 커밋할지 롤백할지를 판단하면 된다.

### 스프링 프레임워크의 JPA 예외 변환

서비스 계츨에서 JPA의 예외를 직접 사용하면 JPA에 의존하게된다. 스프링 프레임워크는 이런 문제를 해결하기 위해 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.

JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor`를 스프링 빈으로 등록하면 된다.

`@Repository`를 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화환 예외로 변환해준다.

### 트랜잭션 롤백 시 주의사항

트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하게 되고 수정한 자바 객체까지 원상태로 복구해주지 않는다.

기본전략인 트랜잭션당 영속성 컨텍스트 전략은 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하기 때문에 문제가 발생하지 않는다.

반면 OSIV처럼 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용하는 경우 트랜잭션을 롤백해서 영속성 컨텍스트에 이상이 발생해도 다른 트랜잭션이 해당 영속성 컨텍스트를 그대로 사용하여 문제가 발생할 수 있다.

따라서 롤백시 영속성 컨텍스트를 초기화해서 잘못된 영속성 컨텍스트를 사용하는 문제를 예방한다.

## 15.2 엔티티 비교

영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 존재하며, 이것은 영속성 컨텍스트와 생명주기를 같이 한다.

- 같은 트랜잭션 범위 안에서 영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족한다.

  - 동일성 : `==` 비교가 같다.
  - 동등성 : `equals()` 비교가 같다.
  - 데이터베이스 동등성 : `@id` 인 데어베이스 식별자가 같다.
  
- 영속성 컨텍스트가 다를때 엔티티 비교는 다음과 같다.

  - 동일성 : `==` 비교가 실패한다.
  - 동등성 : `equals()` 비교가 만족한다. 단 `equals()` 를 구현해야 한다.
  - 데이터베이스 동등성 : `@id` 인 데이터베이스 식별자가 같다.
  
동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다. 그렇지 않은 떄는 비즈니스 키를 사용한 동등성 비교를 해야한다.

## 15.3 프록시 심화 주제

### 영속성 컨텍스트와 프록시

- 프록시 조회 후 원본 엔티티 조회하는 경우

영속성 컨텍스트는 `em.getReference()`를 통해 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.

프록시로 조회해서 영속성 컨텍스트는 영속 엔티티의 동일성을 보장한다.

- 원본 엔티티 조회후 프록시 조회하는 경우

원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 이미 데이터베이스에서 조회했기 때문에 프록시를 반환할 이유가 없다.

따라서 `em.getReference()`를 호춣도 원본 엔티티를 반환한다.

이경우에도 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.

### 프록시 타입 비교

- 프록시로 조회한 엔티티의 타입을 비교할때는 `==` 비교를 하면 안되고 대신에 `instanceof`를 사용해야한다.

- 프록시의 멤버변수에 직접 접근하면 안되고 대신에 접근자 메소드를 사용해야 한다.

### 상속관계와 프록시

프록시를 부모 타입으로 조회하면 문제가 발생한다. 프록시를 부모타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성되어 하위 타입과 다른 타입으로 생성되고 하위 타입으로 다운캐스팅 할 수 없고 `instanceof`연산을 사용할 수 없다.

상속관계에서 발생하는 프록시 문제를 해결하기 위한 방법

- JPQL로 대상 직접 조회

  - 처음부터 자식 타입을 직접 조회해 필요한 연산을 수행
  - 이 방법의 경우 다형성을 활용할 수 없다.
  
- 프록시 벗기기

  - 하이버네이트가 제공하는 기능을 통해 원본 엔티티를 가져옴
  - 이 방법의 경우 프록시에서 원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패하게 된다.
  - 원본 엔티티가 꼭 필요한 상황에 사용하고 다른 곳에서 사용되지 않도록 하는 것이 중요하다.
  
- 기능을 위한 별도의 인터페이스 제공

  - 특정 기능을 제공하는 인터페이스를 생성
  - 다형성을 사용하는 좋은 방법이다.
  - 프록시의 특징 때문에 프록시의 대상이 되는 타입에 인터페이스를 적용해야 한다.
  
- 비지터 패턴 사용

  - `Visiotr` 와 `Visitor`를 받아들이는 대상 클래스로 구성된다.
  - 비지터 패턴을 사용하면 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있고 `instanceof`나 타입캐스팅 없이 코드를 구현할 수 있다.
  - 새로운 기능이 추가될 떄 기존 코드 구조 변경 없이 `Visitor`만 추가하면 된다.
  
## 15.4 성능 최적화

JPA로 애플리케이션을 개발할 때 발생하는 다양한 성능 문제와 해결 방안

### N+1 문제

즉시로딩 전략은 `N+1` 문제는 물론 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩해야하는 상황이 자주 발생한다. 또한 성능 최적화가 어렵다.

따라서 모두 지연로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.

- `@OneToOne`, `@ManyToOne` : 기본 페치 전략은 즉시 로딩
- `@OneToMany`, `@ManyToMany` : 기본 페치 전략은 지연 로딩

다른 방법으로는 하이버네이트 `@BatchSize`를 사용하여 지정해둔 size만큼 해당 엔티티를 조회할때 SQL의 IN절을 사용하는 방법이 있다.

또한 하이버네이트 `@Fetch(FetchMode.SUBSELECT)` 를 사용하여 연관된 데이터를 조회할때 서브 쿼리를 사용해서 `N+1` 문제를 해결할 수 있다.

### 읽기 전용 쿼리의 성능 최적화

영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다. 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다.

- 스칼라 타입으로 조회
  - 엔티티가 아닌 스칼라 타입으로 모든 필드를 조회한다.

- 읽기 전용 쿼리 힌트 사용
  - 하이버네이트 전용 힌트인 `org.hibernate.readOnly`를 사용해 엔팉를 읽기 전용으로 조회한다.
  - 스냅샷을 보관하지 않기 때문에 엔티티를 수정해도 데이터베이스에 반영되지 않는다.
  
- 읽기 전용 트랜잭션 사용
  - `@Transactional(readOnly = true)` 어노테이션을 사용하여 트랜잭션을 읽기 전용 모드로 설정할 수 있다.
  - 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않으며 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다.
  - 플러시할 때 일어나는 스냅샷 비교와 같은 로직을 수행하지 않기 때문에 성능이 향상된다.
  
- 트랜잭션 밖에서 읽기
  - 트랜잭션 없이 엔티티를 조회한다는 뜻이다.
  - 데이터 변경이 불가능하기 때문에 조회가 목적일때만 사용해야 한다.
  
읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트를 동시에 사용하는것이 가장 효과적이다.

### 배치 처리

수백만 건의 데이터를 처리해야하는 경우 일반적인 방식으로 엔티티를 계속 조회하면 영속성 컨텍스트에 아주 많은 엔티티가 쌓이면서 메모리 부족으로 오류가 발생한다.

따라서 이런 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화해야한다. 또한 2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야 한다.

- JPA 등록 배치

수천에서 수만 건 이상의 엔티티를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록 일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화해야 한다.

배치 처리는 아주 많은 데이터를 조회해서 수정하는 데 수많은 데이터를 한 번에 메모리에 올려둘 수 없어서 2가지 방법을 주로 사용한다.

  - 페이징 처리

  - 커서 : JPA는 JDBC 커서를 지원하지 않는다. 하이버네이트 세션을 사용해야 한다.

데이터베이스 커서(Cursor)는 일련의 데이터에 순차적으로 액세스할 때 검색 및 "현재 위치"를 포함하는 데이터 요소이다. 하이버네이트는 scroll 이라는 이름으로 JDBC 커서를 지원한다.

- 하이버네이트 무상태 세션 사용

하이버네이트는 무상태 세션이라는 특별한 기능을 제공한다. 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다.

무상태 세션은 영속성 컨텍스트가 없기 때문에 엔티티를 수정하려면 무상태 세션이 제공하는 update()메서드를 직접 호출해야 한다.

### SQL 쿼리 힌트 사용

JPA는 데이터베이스 SQL 힌트 기능을 제공하지 않기 때문에 하이버네이트를 직접 사용해야한다.

```java
Session session = em.unwrap(Session.class); //하이버네이트 직접 사용

List<Member> list = session.createQuery("select m from Member m")
                      .addQueryHint("FULL (MEMBER)") //SQL HINT 추가
                      .list();
```
                      
### 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

- 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치

네트워크 호출 한 번은 단순한 메서드를 수만 번 호출하는 것보다 더 큰 비용이 든다.

이것을 최적화하려면 SQL을 모아서 한 번에 데이터베이스로 보내면 된다.

JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한 번에 보낼 수 있다.

SQL 배치 최적화 전략은 구현체마다 조금씩 다르다.

`hibernate.jdbc.batch_size` 속성의 값을 정해 SQL 배치를 실행하게 되며 SQL 배치는 같은 SQL일때만 유효하다.

중간에 다른 처리가 들어가면 SQL 매치를 다시 시작한다.

엔티티가 영속 상태가 되려면 식별자가 꼭 필요하다. 그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스가 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 Insert SQL이 데이터베이스에 전달된다. 따라서 쓰기 지연을 활용한 성능 최적화를 할 수 없다.

- 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성

데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화 한다는 점이 장점이다.

이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트가 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제하지 않는다.

따라서 커밋 직전까지 데이터베이스 로우에 락을 걸지 않는다.

## 15.5 정리

- JPA 예외는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외로 나눈다.
- 스프링 프레임워크는 JPA의 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.
- 같은 영속성 컨텍스트의 엔티티를 비교할 떄는 동일성 비교가 가능하지만 다르면 동일성 비교에 실패한다.
- `N+1` 문제는 주로 페치 조인을 사용해서 해결한다.
- 엔티티를 읽기 전용으로 조회하면 스냅샷을 유지할 필요가 없고 영속성 컨텍스트를 플러시하지 않아도 된다.
- 트랜잭션을 지원하는 쓰기 지연 덕분에 SQL 배치 기능을 사용할 수 있다.