- JPA의 데이터 타입을 가장 크게 분류하면 엔티티 타입과 값 타입으로 나눌 수 있다.
- 엔티티 타입은 `@Entity` 로 정의하는 객체이고, 값 타입은 `int` , `Integer` , `String` 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 의미한다.
- 엔티티 타입은 식별자를 통해 지속적으로 추적 가능하지만 값 타입은 식별자가 없고 숫자나 문자 속성만 있기 때문에 추적이 불가능하다.

<br>

# 9.1 기본값 타입

- `String` , `int` 와 같이 엔티티 내부에서 사용되는 자바 기본타입을 기본 값타입이라고 한다.
- 기본값 타입은 식별자도 없고 생명주기도 엔티티에 의존하기 때문에 엔티티 인스턴스를 제거하면 값타입의 값도 제거된다.
- 값 타입은 공유하면 안되며 만약 이를 공유하게 될경우 값 타입의 변경 포인트가 여러곳에 발생하게되어 유지보수하기 어려워지고 코드를 복잡하게 만든다.

<br>

# 9.2 임베디드 타입 : 복합 값 타입

- JPA에서는 새로운 값 타입을 직접 정의해서 사용할 수 있는데 이것을 임베디드 타입이라고 한다.
- 임베디드 타입도 `int` , `Stirng` 과 같은 기본값 타입과 마찬가지로 값 타입에 속한다.

<br>

## 임베디드 타입의 활용

- 다음과 같이 근무 시작일과 종료일, 주소, 도시, 우편번호를 가지는 `Member` 엔티티가 있다.

<br>

```java
@Entity 
public class Member {
	...
	
	LocalDateTime startDate;
	LocalDateTime endDate;

	private String city;
	private String street;
	private String zipcode;
}
```

<br>

- 위와 같은 코드는 단순히 정보룰 풀어둔 것으로 서로 아무 관련이 없는 정보들을 풀어두는 것 보다는 다음과 같이 서로 관련있는 정보들을 의미있는 단위로 묶어주는 것이 좋다.

```java
@Entity
public class Member {
	...
	
	@Embedded Period workPeriod;
	@Embedded Address homeAddress;
}
```

- 위와 같이 변경할 경우 객체지향적으로 엔티티를 좀 더 의미있고 응집력있게 변경할 수 있다.
- 뿐만 아니라 새로 정의한 값 타입들은 재사용 가능하며 해당 값 타입만 사용 가능한 의미있는 메서드도 만들 수 있다.

<br>

임베디드 타입을 사용하기 위한 제약 조건은 다음과 같다.

- `@Embeddable` 어노테이션을 값 타입을 정의하는 곳에 표시하고 `@Embedded` 어노테이션을 값 타입을 사용하는 곳에 표시한다.
- 두 어노테이션 중 하나를 생략해도 괜찮지만 코드의 가독성을 위해 둘 다 표시하는 것을 권장한다.
- 임베디드 타입은 기본 생성자를 필수로 가지고 있어야한다.

<br>

임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하기 때문에 엔티티와 임베디드 타입의 관계는 컴포지션 관계가 된다.

<br>

## 임베디드 타입의 특징

- 결과적으로 임베디드 타입을 사용한 것과 일반 값 타입을 사용한 것의 테이블 매핑 결과는 동일하지만 임베디드 타입 덕분에 객체와 테이블을 좀 더 세밀하게 매핑하는 것이 가능해진다.
- 임베디드 타입은 또 다른 값 타입을 포함하거나 엔티티를 참조하는 것이 가능하다.
- `@AttributeOverride` 를 이용해서 임베디드 타입에 정의한 매핑 정보를 재정의하는 것이 가능하지만 이를 남용하면 코드가 지저분해진다.
- 임베디드 타입이 `null` 인 경우 매핑한 컬럼값이 전부 `null` 이 된다.

<br>

# 9.3 값 타입과 불변 객체

- 값 타입은 복잡한 객체 세상을 조금이라도 단순화하기 위해 만든 개념이기 때문에 단순하고 안전하게 다룰 수 있어야 한다.

<br>

## 값 타입 공유 참조

- 임베디드 타입과 같은 값 타입을 여러 엔티티에서 공유해서 사용하면 위험하다.
- 값 타입을 공유하고있는 여러 엔티티에서 동시에 값 타입을 수정하거나 또는 다른 엔티티에 의해서 참조하고 있는 값 타입이 수정되는 경우와 같이 의도하지 않는 변경으로 인하여 버그가 발생할 가능성이 존재한다.
- 공유 참조로 인해 발생하는 버그는 찾기 어려우며 여러가지 사이드 이펙트를 발생시킬 수 있는데 이를 막으려면 값을 복사해서 사용해야한다.

<br>

## 값 타입의 복사

- 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하기 때문에 인스턴스를 복사해서 사용해야한다.
- 항상 값을 복사해서 사용하게되면 공유 참조로 인해 발생하는 사이드 이펙트를 피할 수 있다.
- 하지만 문제는 자바는 대입하려는 것이 값 타입인지 아닌지는 신경쓰지 않기 때문에 복사하지 않고 원본의 참조값을 직접 넘기는 것을 막을 방법이 없다.
- 때문에 객체의 공유 참조에서 발생하는 문제를 해결하기 위한 근본적인 해결방법이 필요한데 이는 객체를 불변 객체로 만들어 객체의 값을 수정하지 못하도록 막으면된다.

<br>

## 불변 객체

- 값 타입은 사이드 이펙트 걱정 없이 사용할 수 있어야 하는데 사이드 이펙트가 발생하면 값 타입이라고 할 수 없다.
- 객체를 불변객체로 만들면 값을 수정할 수 없기 때문에 사이드 이펙트를 사전에 방지할 수 있으며 도리 수 있으면 값 타입은 불변 객체로 설계해야 한다.
- 불변 객체를 구현하는 방법에는 다향한 방법이 있지만 가장 간단한 방법은 생서자로만 값을 설정하고 수정자를 생성하지 않는 것이다.

<br>

# 9.4 값 타입의 비교

- 자바에서 제공하는 객체 비교는 동일성 비교와 동등성 비교 두 가지가 존재한다.
- 값이 동일하지만 서로 다른 인스턴스인 두 값 타입을 동일성 `==` 비교 하게되면 결과는 `false` 가 나오게 된다.
- 값 타입은 인스턴스가 달라고 그 안에 값이 같으면 같은 것으로 보아야하기 때문에 `equals()` 메서드를 이용하여 동등성 비교를 수행해야 한다.
- 값 타입의 `equals()` 메서드를 재정의할 때는 보통 모든 필드값을 비교하도록 구현하며 이와 동시에 `hashCode()` 도 함께 재정의하는 것이 안전하다.

<br>

# 9.5 값 타입 컬렉션

- 값 타입을 하나 이상 저장하려면 컬렉션이 보관하고 `@ElementCollection` , `@CollectionTable` 어노테이션을 사용하면된다.

<br>

```java
@Entity
public class Member {

	...
	
	@ElementCollection
	@CollectionTable(name = "FAVORITE_FOODS",
				joinColumns = @JoinColumn(name = "MEMBER_ID"))
	@Column(name = "FOOD_NAME")
	private Set<String> favoriteFoods = new HashSet<>();

	@ElementCollection
	@CollectionTable(name = "ADDRESS",
				joinColumns = @JoinColumn(name = "MEMBER_ID"))
	private List<Address> addressHistory = new ArrayList<>();

}
```

<br>

- 위의 예시에서 회원 엔티티는 값 타입 컬렉션을 사용하는데 이것을 관계형 데이터베이스 테이블로 매핑할 때 테이블은 컬럼 내부에 컬렉션을 포함할 수 없기 때문에 별도의 테이블을 추가해서 추가한 테이블과 매핑을 수행해야한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9cf5252c-5f56-4f06-8dcf-fd4534eadfc1/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3a1e326b-c6c2-4a5b-9816-1fa1fca012fb%2FUntitled.png?table=block&id=e7f337b8-4134-4252-b43c-767d55601eb6&spaceId=7bf4105e-471a-416e-8171-751ccdb35ff5&width=590&userId=&cache=v2)

<br>

## 값 타입 컬렉션 사용

```java
Member member = new Member();

//임베디드 값 타입
member.setHomeAddress(new Address("통영","몽돌해수욕장","660-123"));

//기본값 타입 컬렉션 
member.getFavoriteFoods().add("짬뽕"); 
member.getFavoriteFoods().add("짜장"); 
member.getFavoriteFoods().add("탕수육");

//임베디드 값 타입 컬렉션
member.getAddressHistory().add(new Address("서울","강남","123-123")); 
member.getAddressHistory().add(new Address("서울","강북","000-000"));

em.persist(member);
```

<br>

- 위와 같은 코드를 실행한다고 했을 때 실제로는 회원 엔티티만 영속화했지만 JPA는 엔티티의 값 타입도 함께 저장한다.
- 때문에 실제로 데이터베이스에 실행되는 SQL은 다음과 같다.
    - 회원 엔티티 삽입 SQL 1번
    - 회원의 집주소에 해당하는 값 타입 삽입 SQL은 회원 엔티티 삽입 SQL에 포함된다.
    - 회원의 좋아하는 음식에 해당하는 값 타입 삽입 SQL 3번
    - 회원의 주소 기록에 해당하는 값 타입 삽입 SQL 2번
- 회원 엔티티만 영속화를 수행했지만 회원 엔티티를 제외한 총 5개의 SQL이 추가적으로 수행됨을 확인할 수 있다.
- 값 타입 컬렉션은 영속성 전이와 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.
- 값 타입 컬렉션 조회도 `fetch` 전략을 선택할 수 있으며 기본 `fetch` 전략은 `LAZY` 이다.

<br>

### 값 타입의 수정과 값 타입 컬렉션의 수정

- 임베디드 값 타입을 수정하는 경우 엔티티 테이블과 직접 매핑되기 때문에 엔티티 테이블만 업데이트하며 이는 엔티티를 수정하는 것과 동일하다.
- `String` 과 같은 기본값 타입 컬렉션을 수정하는 경우 자바의 `String` 은 불변객체이기 때문에 수정하려는 `String` 객체를 제거하고 새로운 값을 추가해야한다.
- 임베디드 값 타입 컬렉션을 수정하는 경우 값 타입은 불변해야하는 원칙에 따라서 기본 값 타입과 동일하게 수정하려는 값 타입 객체를 컬렉션에서 제거하고 새로운 값 타입 객체를 저장해야한다.

<br>

## 값 타입 컬렉션의 제약사항

- 엔티티는 식별자가 존재하기 떄문에 엔티티의 값을 변경해도 식별자로 데이터베이스에 저장된 원본 데이터를 쉽게 찾아서 변경할 수 있다.
- 반면 값 타입은 식별자라는 개념이 없고 단순한 값들의 모음이기 떄문에 값을 변경하면 데이터베이스에 저장된 원본 데이터를 찾기 어렵다.
- 특정 엔티티 하나에 소속된 값 타입은 값이 변경되어도 자신이 소속된 엔티티를 데이터베이스에서 찾고 값을 변경하면 되지만 문제는 값 타입 컬렉션이다.
- 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이븡레 보관되며 보관된 값이 변경되면 데이터베이스에 존재하는 원본 데이터를 찾기 어렵다는 문제가 있다.
- 이러한 문제로 인하여 JPA 구현체들은 값 타입 컬렉션에 변경 사항이 발생하면 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시 저장한다.
- 추가로 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야하는데 데이터베이스의 기본키 제약조건으로 인해 컬럼에 `null` 을 입력할 수 없고 같은 값을 중복해서 저장할 수 없다는 제약 사항도 존재한다.
- 떄문에 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 또는 값 타입의 여러가지 제약사항으로 인한 문제점을 해결하기 위해서는 값 타입 컬렉션 대신 1:N 관계를 사용하면된다.
- 1:N 관계로 새로운 엔티티를 생성하고 영속성 전이와 고아 객체 제거 기능을 적용하면 값 타입 컬렉션과 동일하게 사용할 수 있다.
