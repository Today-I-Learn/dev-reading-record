# 잘못된 예외처리 방법

- 예외를 아무것도 하지 않고 별문제가 없는 것 처럼 넘어가 버리는 것은 매우 위험한 일이다 이것은 원치않는 예외가 발생하는 것보다 훨씬 나쁜 일이다.

<br>

## 처리되지 않은 예외

- 프로그램 실행 중에 어디선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버린다는 의미이다.
- 결국 이러한 동작방식은 발생한 예외로 인하여 비정상 동작이나 메모리 리소스가 소진되거나 예상치 못한 다른 문제를 일으킬 잠재적 위험성을 가지고 있다.
- 뿐만 아니라 오류나 이상한 결과의 원인이 무엇인지 찾아내기가 매우 힘들다는 점이다.

<br>

## 단순히 예외를 출력하는 처리방법

```java
try {
	...
} catch(Exception e) {
	e.printStackTrace();
}
```

이렇게 예외를 단순히 `printStackTrace` 나 `print` 를 통해 그냥 콘솔에 출력해버리는 방법도 문제가 있다.

- 다른 로그나 메세지에 금방 묻혀버리면 놓치기 쉬울 뿐더러 누군가는 이를 계속 모니터링 해야한다.
- 결국 누군가에 의해서 지속적으로 모니터링 되고 처리되지 않는한 이 예외는 심각한 잠재적 위험성을 가지고 남아있을 것이다.

예외에서 가장 중요한 것은 발생한 예외가 반드시 어떠한 형태로든 처리되어야 한다는 것이다. 단순히 메세지를 출력한 것은 예외를 처리한 것이 아니다.

- 모든 예외는 적절하게 복구되던지 아니면 작업을 중단시키고 개발자 또는 운영자에게 통보되어야 한다.

<br>

## 무의미 무책임한 throws

```java
public void method() throws Exception {
	...
}
```

위와 같이 메서드 선언에 `throws Exception` 을 기계적으로 붙여 모든 예외를 무조건 던져버리는 무책임한 `throws` 선언도 문제가 있다.

- 위와 같은 방법은 메서드 선언에서 예외적인 상황이 발생할 수 있는지 아니면 습관적으로 붙여넣은 것인지 의미있는 정보를 파악할 수가 없다.
- 이러한 방식은 적절한 처리를 통해 복구될 수 있는 예외상황도 기회를 박탈당하게된다.

<br>

# Java의 예외의 종류와 특징

- Java에서 `throw` 를 통해 발생시킬 수 있는 예외는 3가지 종류가 존재한다.

<br>

## Error

- 비정상적인 상황이 발생했을 경우 사용되며 주로 JVM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다.
- 왜냐하면 OutOfMemoryError 또는 ThreadDeath와 같은 에러는 잡아봤자 애플리케이션 레벨에서 아무런 대응 방법이 존재하지 않는다.

<br>

## Exception 과 CheckedException

- 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용되며 Exception은 다시 CheckedException과 UncheckedException으로 구분되어진다.
- UncheckedException의 경우에는 Exception의 서브 클래스이면서 RuntimeException을 상속한 클래스들을 의미한다.
- CheckedException이 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 작성해야 한다.
- 만약 사용할 메서드가 CheckedException을 던진다면 이를 `catch` 를 이용해서 잡던지 아니면 `throws` 를 정의해서 메서드 밖으로 던져야한다.
- IOException, SQLException 등이 대표적인 CheckedException에 속한다.

<br>

## RuntimeException 과 UncheckedException

- RuntimeException을 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 UncheckedException으로 불린다.
- RuntimeException은 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들로 NullPointerException, IllegalArgumentException 등이 이에 해당된다.
- 이러한 예외들은 피할 수 있지만 개발자의 부주의에 의해서 발생할 수 있는 경우에 발생하도록 설계되었으며 예상하지 못했던 예외상황에서 발생한 것이 아니기 때문에 굳이 `catch` , `throws` 를 사용하여 예외를 처리하도록 강제하지않는다.

CheckedException은 예외처리를 강제하기 때문에 예외를 제대로 처리하지 않거나 무책임한 `throws` 같은 코드가 남발되었는데 최근 Java API 들은 예상가능한 예외상황을 다루는 예외들을 CheckedException으로 만들지 않는 추세이다.

<br>

# 다양한 예외 처리 방법

- 먼저 예외를 처리하는 일반적인 방법들에 대해서 알아보고 효과적인 예외처리 전략에 대해서 생각해보자.

<br>

## 예외 복구

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법을 의미한다.
- 예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도를 하는 등의 처리가 이루어져야 한다.
- 예외가 처리되었으면 기능적으로 사용자에게 예외상황으로 비추어져도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행되어야 한다.

<br>

### 예외 복구 방법의 예시

- 사용자가 요청한 파일이 없거나 다른 문제 때문에 IOException이 발생한 경우
    - 사용자에게 예외 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결한다. (다른 작업 흐름으로 자연스럽게 유도하는 처리방식)
- 네트워크가 불안정해서 서버 접속이 잘 되지않는 열악한 환경의 시스템에서 원격 데이터베이스 서버에 접속하다 실패해서 SQLException이 발생한 경우
    - 네트워크 접속이 원할하지 않아서 SQLException이 발생하는 경우 일정 시간 대기했다가 다시 시도해보는 방법을 통해 예외상황으로부터 복구를 시도한다.
    - 만약 정해진 횟수 이상 재시도해서 실패하는 경우 예외복구를 포기하도록 한다. (예외에 대한 적절한 처리를 시도해보도록 요구하는 방법)

즉, 예외 복구와 같이 예외처리 코드를 강제하는 CheckedException의 경우 예외를 어떤식으로든 복구할 가능성이 있는 경우에 사용한다. 

<br>

## 예외 회피

- 예외처리를 자신이 수행하지않고 자신을 호출한 쪽으로 던져버리는 방법으로 `throws` 를 선언해서 예외가 발생하면 알아서 던져지게 하거나 `catch` 로 잡은다음 로그를 남기고 다시 예외를 던지는 방식으로 구현할 수 있다.
- 예외처리를 회피하려면 반드시 다른 오브젝트나 메서드가 예외를 대신 처리할 수 있도록 던져주어야 한다.
- 예외를 그냥 던져버리는 것은 무책임한 회피가 될 수 있기 때문에 복구와 마찬가지로 의도가 분명해야 한다.
- 템플릿 콜백 패턴처럼 긴밀한 관계에있는 다른 오브젝트에게 예외처리 책임을 분명하게 지게하거나 자신을 사용하는 쪽에서 예외를 다루게 하는 것이 최선이라는 확신이 있어야 한다.

<br>

### 예외 회피 방법의 예시

- JdbcContext, JdbcTemplate 등이 사용하는 콜백 오브젝트는 SQLException을 자신이 처리하지 않고 템플릿으로 던져버린다.
    - SQLException을 처리하는 일은 콜백 오브젝트의 일이 아니라고 보기 때문에 SQLException에 대한 예외를 회피하고 템플릿 레벨에서 처리하도록 한다.

<br>

## 예외 전환

- 예외 전환은 회피와 마찬가지로 예외를 복구해서 정상적으로 만들 수 없기 때문에 메서드 밖으로 예외를 던지는 것이다.
- 단 예외를 회피하는 방법과 구별되는 특징은 예외를 그대로 던지는 것이 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.
- 예외 전환을 사용하는 이유에는 여러가지가 있는데 보통 두가지 목적으로 사용된다.
    - 내부에서 발생한 예외를 그대로 던지는 것이 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서
    - 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하려는 경우 중첩된 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부로 담아서 던지는 방식으로 주로 예외처리를 강제하는 CheckedException을 UncheckedException으로 바꾸기 위해서

<br>

### 예외 전환 방법의 예시

- 사용자 등록시 중복되는 아이디가 존재해서 데이터베이스 에러가 발생하여 JDBC API가 SQLException이 발생시킨 경우 (적절한 의미를 부여해주지 못하는 예외를 의미가 분명한 예외로 바꾸어 전달하기 위해서)
    - DAO의 메서드가 SQLException을 그대로 밖으로 던져버린다면 서비스 계층에서는 왜 SQLExceptio이 발생했는지 쉽게 알 방법이 없다.
    - 아이디 중복의 경우 충분히 예상가능하고 복구 가능한 예외상황이기 때문에 SQLException을 해석해서 DuplicateUserIdException 같은 예외로 바꾸어 던져줄 수 있다.
    - 이러한 경우 서비스 계층에서 적절한 복구 작업을 시도하는 것이 가능하다.
- CheckedException인 SQLException의 대부분은 애플리케이션 레벨에서 복구가 불가능한 경우가 대부분이다. (CheckedException을 UnCheckedException으로 전환하기 위해서)
    - 어짜피 복구가 불가능한 예외라면 가능한 빨리 RuntimeExcption으로 포장해서 던지게해서 다른 계층의 메서드를 작성할 때 불필요한 `throws` 선언이 들어가지 않도록 해주어야한다.
    - 대부분의 서버 환경에서 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공하며 어짜피 복구하지 못할 예외라면 RuntimeException으로 포장해서 던져버리고 예외처리 서비스 등을 이용해 로그를 남기고 관리자에게는 메일로 사용자에게는 안내 메세지로 보여주는 식으로 처리하는 것이 바람직하다.

애플리케이션 코드에서 의도적으로 던지는 예외 즉, 비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응이나 복구 작업이 필요하기 때문에 CheckedException을 사용하는 것이 적절하지만 일반적으로 CheckedException을 계속해서 `throws` 를 사용해 넘기는 것은 무의미하므로 처리하지 못할 예외라면 가능하면 빠르게 RuntimeException으로 전환해서 다른 계층으로 예외가 확산되지 않게 하는 것이 좋다.

<br>

# 서버 환경에서 예외를 효과적으로 처리하는 방법

- 일반적으로 CheckedException이 일반적인 예외를 다루고 UncheckedException은 시스템 장애나 프로그램상의 오류에 사용된다.
- CheckedExcpeiton은 복구할 가능성이 조금이라도 존재하기 때문에 Java에서는 이를 처리하는 `catch` 나 `throws` 선언을 강제하고 있다.
- 하지만 Java 엔터프라이즈 서버 환경은 조금 다르다 수많은 사용자가 동시에 요청을 보내거나 각 요청이 독립적인 작업으로 취급되기 때문에 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중지시키면 그만이다.
- 서버는 특정 계층에서 예외가 발생했을 경우 작업을 일시 중지하고 사용자와 커뮤니케이션을 통해 예외상황을 복구할 수 있는 방법이 존재하지 않는다.
- 때문에 애플리케이션 차원에서 예외상황을 미리 파악하고 발생하지 않도록 차단하는 것이 좋고 외부 환경으로 인한 예외라면 요청을 취소하고 관리자에게 통보해주는 것이 좋다.
- 즉, 서버 환경으로 이동하면서 점차 CheckedException의 활용도와 가치가 줄어들고 있다는 것으로 대응이 불가능한 CheckedException이라면 가능한 빠르게 RuntimeException으로 전환해서 던지는 것이 낫다.

<br>

## 애플리케이션에서의 예외

- 애플리케이션 예외는 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 반드시 `catch` 해서 무엇인가 조치를 취하도록 요구하는 예외이다.

<br>

### 은행계좌에서 출금하는 기능에 대한 예외처리

- 계좌에서 출금하는 기능의 경우 현재 잔고를 확인해서 허용하는 범위 외의 출금을 요청하는 경우 작업을 중단시키고 적절한 경고를 사용자에게 보내야한다.
- 정상 상태와 비정상 상태의 결과값을 다르게 반환하도록 설계
    - 명확한 설계 기준이 없으면 혼란이 생길 수 있으며 표준이 없다면 의사소통 문제 및 결과값을 확인하는 조건문이 자주 등장하여 코드가 지저분해진다.
- 예외상황에만 비즈니스적 의미를 가지는 예외를 던지도록 한다.
    - 예외를 만드는 코드와 처리하는 코드를 분리할 수 있으며 이러한 경우 번거로운 조건문을 반복하지 않아도 되기 때문에 설계가 단순해진다.

<br>

# SpringFramework에서 SQLException 처리 전략

- 가장 먼저 고려해야할 점은 SQLException이 과연 복구가 가능한 예외인가라는 점이다.
- SQLException은 거의 대부분의 경우에 코드 레벨에서 복구할 방법이 존재하지 않는다 프로그램의 오류 또는 개발자의 부주의 때문에 발생하거나 통제할 수 없는 외부상황 때문에 발생하는 경우가 대부분이다.
- 이와 같은 상황들은 SQL 문법이 틀렸거나 제약 조건위반, 데이터베이스 서버의 장애 및 네트워크 불안정, 데이터베이스 커넥션 풀의 포화로 인한 커넥션을 가져올 수 없는 경우 등이 해당한다.
- 대부분의 SQLException은 복구가 불가능하기 때문에 가능한 빠르게 RuntimeException으로 전환해주어야 한다.
- JdbcTemplate은 이러한 예외처리 전략을 잘 따르고 있는데 템플릿과 콜백 안에서 발생하는 모든 SQLException은 RuntimeException인 DataAccessException으로 포장해서 던져준다.

<br>

## JDBC의 한계점

<br>

### 비표준 SQL 구문

- SQL은 어느정도 표준화된 언어이고 표준 규약이 존재하지만 대부분의 데이터베이스는 표준을 따르지 않는 비표준 문법과 기능이 존재한다.
- 비표준 SQL은 결국 특정 데이터베이스에 종속적인 코드를 만들게 되는데 이는 곧 다른 데이터베이스로 변경을 시도할 경우 많은 부분을 수정해야함을 의미한다.

<br>

### 호환성 없는 SQLException 데이터베이스 에러 정보

- SQLException이 발생할 수 있는 원인은 수백가지가 있는데 JDBC는 데이터 처리중에 발생하는 예외를 모두 SQLException에 담아서 던진다.
- 예외정보를 확인하기 위해서는 에러코드와 SQL 상태정보를 모두 확인해야하는데 데이터베이스마다 서로다른 고유한 에러코드를 사용하기 때문에 이와 같은 방법은 특정 데이터베이스에 종속적인 코드를 만들게 된다.
- JDBC에서는 특정 상태코드를 제공하여 표준화하려고 하지만 각 데이터베이스 벤더에서 이를 정확하게 만들어주지는 않는다.
- 때문에 SQL 상태코드만 믿고 결과를 파악하는 것은 위험하며 SQLException 만으로는 데이터베이스에 독립적이고 유연한 코드를 작성하는 것이 불가능하다.

<br>

## DataAccessException 예외 전환

- 예외 전환의 목적은 위에서 언급한 것 처럼 RutnimeException으로 포장하기 위함과 의미있고 추상화된 예외로 바꾸어서 던져주기 위함이다.
- DataAccessException은 RuntimeException으로 SQLException을 포장해주는 역할을 할 뿐만 아니라 상세한 예외정보를 의미있고 일관성있는 예외로 전환해서 추상화해주려는 용도로 사용된다.
- DataAccessException은 SQLException을 대체할 수 있는 RuntimeException을 정의하고있을 뿐만 아니라 서브 클래스로 세분화된 예외 클래스들을 정의하고있다.
- 데이터 엑세스 상황 중에 발생할 수 있는 예외상황을 수십가지로 분류하고 이를 추상화해서 정의한 다양한 예외 클래스를 제공하며 데이터베이스별 에러코드를 분류해서 스프링이 정의한 예외 클래스와 매핑하는 매핑정보 테이블을 이용하고있다.
- DataAccessException은 데이터 엑세스 기술에 상관없이 일관된 예외가 발생하도록 만들어주기 때문에 데이터 엑세스 기술에 독립적인 추상화된 예외를 제공한다.
- 이러한 예외 추상화는 JDBC, JPA, Hibernate 등에 상관없이 데이터 엑세스 기술에 관계없이 비슷한 성격의 예외를 추상화된 예외로 던져주게되기 때문에 일관성 있는 예외를 던질 수 있도록 해준다.

<br>

### DataAccessException의 한계점

- 데이터 엑세스 기술에 따라서 세분화된 정도가 다르기 때문에 좀 더 디테일한 예외 대신에 포괄적인 예외로 처리할 수 밖에 없다.
- 때문에 다른 상황에서도 동일한 예외가 발생할 가능성이 있기 때문에 예외에 대한 이용가치가 떨어지게된다.
