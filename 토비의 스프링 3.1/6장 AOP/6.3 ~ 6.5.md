## 6.3 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

앞선 과정들을 살펴보자면 다음과 같은 절차를 통해 트랜잭션(부가) 기능과 비즈니스(핵심) 로직을 분리시켰다.
1.  추상화를 활용하여 전략 패턴을 적용시켜 부가 기능의 구현 내용을 분리
2. 구분된 핵심 코드와 부가 코드를 분리시켜 두 클래스로 독립
3. 클라이언트는 부가 기능을 모르는 채 핵심 기능 인터페이스에 접근하여 핵심 기능을 사용할 것이라 기대  
 -> 실제로는 DI를 활용하여 부가기능이 핵심 기능보다 앞서 사용되어 *부가 기능을 통해 핵심 기능*을 사용한다.

마지막 단계의 부가기능에서처럼 **클라이언트가 사용하려하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것**을 **프록시**(proxy, 대리자·대리인)이라고 부른다.  
부가기능에서 위임해서 핵심 기능을 수행하는 것처럼 **최종적으로 요청을 위임받아 처리하는 실제 오브젝트**를 **타깃**(target), **실체**(real subject)라고 부른다.

**데코레이터 패턴**은 타깃의 부가 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다. 다음 위임 대상을 인터페이스로 선언하고 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어, 프록시의 개수, 순서, 방법을 런타임 시에 조합해서 사용할 수 있다.
> 예시) IO패키지의 `InputStream`  
  `InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));`  


**프록시 패턴**은 타깃에 접근하는 방법을 제어하기 위해 프록시를 사용하는 패턴을 말한다. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨줄 때, 실제 타깃이 아닌 프록시를 넘겨주고 메소드를 통해 사용하려고 접근하면 그 때 타깃을 생성하여 요청을 위임한다. 
> 예시) Collections의 `unmodifiableCollection()`  
  -> 파라미터로 전달된 Collection 오브젝트의 프록시를 만들어서 `add()`나 `remove()` 정보를 수정하는 메소드 호출시 예외 발생

> 주의! 프록시 용어의 혼용  
    - 타깃의 부가 기능을 담당하는 대리 역할 오브젝트   
    - 접근 제어를 담당하는 오브젝트 (프록시 패턴)

<br>

### 다이내믹 프록시를 이용한 트랜잭션 부가기능

위임과 부가작업 역할을 하는 프록시를 만들기 번거로운 이유는 다음과 같다.
 1. 타깃 인터페이스를 구현, 위임하는 코드 작성이 번거롭다.  
 2. 부가 기능 코드가 중복될 가능성이 많다.  

```java
public class UserSerivceTx implements UserSerivce {
    UserSerivce userSerivce;
    ...

    public void add(User user) { //메소드 구현과 위임
        this.userSerivce.add(user);  
    }

    public void upgradeLevels(){ //메소드 구현
        TransactionStatus status = this.transactionManager
                .getTransaction(new DefaultTransactionDefinition());
        try { // 부가기능 수행
        
            userSerivce.upgradeLevels(); //위임

            this.transactionManager.commit(status); //부가기능 수행
        } catch (RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    } 

} 
// 타깃의 모든 메소드를 구현, 위임해야함 (비즈니스 로직이 추가되면 부담 多)
// 부가기능이 여러개가 된다면? 메소드마다 중복되는 부담
```

부가 기능의 중복은 코드를 분리하여 해결할 수 있고, 인터페이스의 구현과 위임은 JDK의 다이내믹 프록시를 활용하면 해결할 수 있다.

**다이내믹 프록시**는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다. 타깃의 인터페이스와 같은 타입으로 타깃 오브젝트의 메소드를 호출함으로써, **프록시**를 만들 때 인터페이스를 모두 구현하지 않고 <U>다이내믹 프록시의 구현</U>을 하여 **부가 코드만을 제공**하여 부가 기능을 수행할 수 있다. 
 > 다이내믹 프록시의 `invoke()`라는 메소드에서는 리플렉션을 활용한다. 리플렉션 기능은 Class 타입의 오브젝트를 가져와 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.  

```java
public interface InvocationHandler() {
    public Object invoke(Object proxy, Method method, Object[] args);
}

public class TransactionHandler implements InvocationHandler {
    private Object target;
    private PlatformTransactionManager transactionManager;
    private String pattern;

    ...
    // 트랜잭션 적용 대상 메소드를 선별하여 경계설정 부여
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getName().startsWith(pattern)) {
            return invokeInTransaction(method, args);
        } else{
            return method.invoke(target, args);
        }
    }

    public Object invokeInTransaction(Method method, Object[] args) throws Throwable {
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            Object ret = method.invoke(target, args);
            transactionManager.commit(status);
            return ret;
        } catch (InvocationTargetException e) { 
          //invoke로 발생하는 예외는 InvokeTargetException으로 포장
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

다이내믹 프록시를 적용함으로써 핵심 인터페이스의 메소드가 늘어날 때마다 구현해야했던 이전과는 간편해졌고, 메소드의 리턴 타입, 메소드 이름 등등을 유연하게 확인하여 부가 기능을 적용할 수 있다.


### 다이내믹 프록시를 위한 팩토리 빈

다이내믹 프록시에 DI를 적용하려 했으나, 일반적인 스프링의 빈은 지정된 클래스 이름을 가지고 리플렉션을 이용하여 해당 클래스의 오브젝트를 만든 방법을 활용하므로 다이내믹 프록시는 등록할 수 없다. 그밖에 빈을 생성할 수 있는 방법 중에서 대표적으로 팩토리 빈을 활용할 수 있다.

팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈이다. 가장 간단한 `FactoryBean` 인터페이스를 구현하여 생성할 수 있다.  

스프링 빈에 팩토리 빈과 `UserServiceImpl`를 설정하고, 팩토리 빈에서는 빈 설정으로부터 핵심 기능을 주입받아 `TransactionHandler`와 다이내믹 프록시를 생성할 수 있다. 결과적으로는 빈의 주입과 팩토리 빈의 조합을 통해 적절한 DI를 활용할 수 있고, 클라이언트에게는 핵심 기능을 사용한다고 대리 전달할 수 있다.

```java
public class TxProxyFactoryBean implements FactoryBean<Object> {
    Object target;
    PlatformTransactionManager transactionManager;
    String pattern; // 세 가지는 TransactionHandler를 생성할때 필요
    Class<?> serviceInterface; //다이내믹 프록시를 생성할때 필요, 다른 타깃에도 적용 가능

    ...
    // FactoryBean 인터페이스 구현 메소드
    public Object getObject() throws Exception {
        TransactionHandler txHandler = new TransactionHandler();
        txHandler.setTarget(target);
        txHandler.setTransactionManager(transactionManager);
        txHandler.setPattern(pattern);
        return Proxy.newProxyInstance(
            getClass().getClassLoader(), new Class[] { serviceInterface },
            txHandler);
    }

    public Class<?> getObjectType() {
        return serviceInterface;
    }

    public boolean isSingleton() {
        return false;
    }
}
```

### 프록시 팩토리 빈 방식의 장점과 한계

✔ 장점
- `TxProxyFactoryBean`은 코드의 수정 없이도 다양한 클래스에 적용할 수 있다.
- 프록시를 적용하기 어려웠던 두 가지 문제점을 해결하였다.
  > DI를 활용하여 타깃 인터페이스를 구현하는 클래스를 일일히 만들 필요가 없으며, 하나의 핸들러로 많은 메소드에 부가기능을 부여해줄 수 있게 되었다.

✔ 단점
- 공통적인 부가 기능의 적용이 하나의 클래스 + 여러 메소드는 가능했으나, 여러 클래스는 불가능하다.
- 하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어렵다.
  > 하나의 타깃에 보안, 트랜잭션, 기능 검사... 부가 기능 개수만큼 프록시 팩토리 빈 설정이 늘어남
- `TransactionHandler` 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다.
  > 프로퍼티로 타깃 오브젝트를 가지고 있으므로 타깃 오브젝트가 달라질 때마다 새로 생성되어야한다. 고로 중복을 없애고 모든 타깃에 적용 가능한 싱글톤 빈으로 만드는 해결법을 찾아야한다.

<br><br>

## 6.4 스프링의 프록시 팩토리 빈

### ProxyFactoryBean

스프링은 `ProxyFactoryBean` 이라는 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공한다. 프록시를 생성해서 빈 오브젝트로 등록함으로써, 순수 프록시를 생성하는 작업만 담당한다.  

- **어드바이스** : 타깃이 필요 없는 순수한 부가 기능

  스프링에서는 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 *어드바이스(Advice)* 라고 부른다. 프록시에서 사용할 부가기능은 이 `Advice`를 상속하고 있는 서브 인터페이스 `MethodInterceptor` 를 구현해서 만든다. `ProxyFactoryBean`에는 여러 개의 `MethodInterceptor`를 추가할 수 있어 기존의  부가기능 추가시마다 팩토리 빈도 추가해줘야했던 문제점을 해결할 수 있다.

  어드바이스의 `invoke()` 메소드에서는 `ProxyFactoryBean`으로부터 타깃 오브젝트의 메소드를 실행할 수 있는 `MethodInvocation`를 제공받기 때문에 **타깃** 오브젝트와는 **독립**적으로 만들 수 있고, 여러 프록시에서 함께 사용 및 싱글톤 빈으로 등록이 가능하다. 작은 단위의 템플릿/콜백 구조를 응용하여 일종의 공유가능한 템플릿처럼 `MethodInvocation` 구현 클래스를 싱글톤으로 두고 동작할 수 있다. 
  
  기존과는 달리 핵심 기능 인터페이스를 제공하지 않아도 `ProxyFactoryBean`에서는 *인터페이스 자동검출 기능*을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알 수 있어, 타깃 오브젝트가 구현하는 모든 인터페이스를 동일하게 구현하는 프록시를 만든다.
  ```java
  // 기존의 사용법
  TxProxyFactoryBean txProxyFactoryBean = context.getBean("&hello", TxProxyFactoryBean.class); // "Hello 인터페이스"를 직접 제공
  txProxyFactoryBean.setTarget(new Hello());
  Hello proxiedHello = (Hello) txProxyFactoryBean.getObject();

  //이후 사용법
  //ProxyFactoryBean pfBean = context.getBean("&hello", ProxyFactoryBean.class); 직접 제공해도 무관
  ProxyFactoryBean pfBean = new ProxyFactoryBean();
  pfBean.setTarget(new HelloTarget());
  pfBean.addAdvicee(new ProxyAdvice());  // 부가기능 MethodInterceptor 추가
  Hello proxiedHello = (Hello) pfBean.getObject();
  ```


- **포인트 컷** : 부가기능 적용 대상 메소드 선정 방법  

  기존의 방식에서는 다음과 같은 방식으로 메소드를 선정하였다.  
  1. 다이내믹 프록시에서 모든 메소드 요청을 보낸다.
  2. `InvocationHandler`에서 부가기능과 메소드 선정 알고리즘(`pattern`)을 수행한다.  
  3. 위임받은 타깃이 핵심 기능을 수행한다.

  문제는 `InvocationHandler`이 타깃과 메소드 선정 알고리즘 코드에 의존하고 있어, 타깃과 메소드 선정 방식이 다르면 여러 프록시가 공유해서 사용할 수 없다. 그러므로 따로 빈으로 등록하기보다는 팩토리 빈에서 매번 생성해주었다. 이러한 구조에서 둘 중 하나의 변경이 일어나더라도 팩토리 빈의 프록시 생성코드도 직접 변경해야한다. 즉, **OCP 원칙**을 지키지 못했다.


  반면 스프링의 `ProxyFactoryBean`에서는 두 가지 확장기능인 **부가기능(Advice)** 와 **메소드 선정 알고리즘(Pointcut)** 을 활용하는 유연한 구조를 제공한다.
  1. 다이내믹 프록시에서 포인트 컷(`Pointcut` 인터페이스 구현체)으로 기능 부가 대상 확인 요청을 보낸다.
  2. 프록시에서 선정된 메소드만 어드바이스(`MethodInterceptor` 구현체)를 호출한다.
  3. 프록시로부터 전달받은 `MethodInvocation` 콜백 오브젝트의 `proceed()`를 호출한다.
  4. 위임받은 타깃이 핵심 기능을 수행한다.

  프록시는 메소드 호출에 따라 `Invocation` 콜백을 만든다. 이는 타깃 오브젝트의 레퍼런스를 갖고 있고, 타깃 메소드를 직접 호출한다. 즉, 재사용 가능한 템플릿인 어드바이스가 바뀌는 부분인 콜백 오브젝트를 외부에서 주입받아 작업 흐름(부가기능 부여) 중에 사용하는 **템플릿/콜백 구조**다. 또한 DI를 이용하여 프록시로부터 어드바이스, 포인트컷을 전략패턴 구조이다.  
  이는 프록시와 `ProxyFactoryBean`의 변경 없이도 기능을 자유롭게 확장할 수 있는 **OCP**를 충분히 만족시켰다.

- **Advisor = Pointcut + Advice**  
  `pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));`  
  포인트 컷이 필요 없을 때는 `addAdvice()`를 호출해서 어드바이스만 등록했지만, 어드바이스와 포인트 컷은 세트로 등록해야한다. 어떤 어드바이스에 어떤 포인트 컷을 적용해야할지 모르기 때문이다.


### ProxyFactoryBean 적용

```java
public class TransactionAdvice implements MethodInterceptor {
    PlatformTransactionManager transactionManager;

    ...
    public Object invoke(MethodInvocation invocation) throws Throwable {
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            Object ret = invocation.proceed();  // 콜백을 호출하여 타깃 메소드를 실행, 전후로 부가기능을 넣을 수 있다.
            this.transactionManager.commit(status);
            return ret;
        } catch (RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    }
}
```

기존의 `FactoryBean`과 부가 기능을 수행하던 `InvocationHandler`에서는 구체적인 타깃을 주고 받고, 부가기능과 메소드 선정 방식이 밀접하게 연결되어있어 OCP를 만족시키지 못하는 구조였다. 

반면 `ProxyFactoryBean`은 DI, 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 적용되어 독립적이고 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있다.

## 6.5 스프링 AOP
