스프링은 자바로 기반으로 한 기술로 스프링이 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍입니다. 즉, EJB를 사용함으로써 잃어버렸던 객체지향의 진정한 가치를 회복시키고 객체지향이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 핵심 철학입니다.

때문에 스프링은 객체에 가장 많은 관심을두고 있으며 스프링을 이해하기 위해서는 객체에 깊은 관심을 가져야 합니다.

- 애플리케이션에서 객체가 생성되고 관계를 맺고 사용되고 소멸되기까지의 전반적인 과정은 어떻게 이루어지는지
- 객체는 어떻게 설계되어야 하며 어떤 단위로 만들어지고 어떤 과정을 통해 존재를 드러내고 등장해야하는지

결국 이러한 객체에 대한 관심은 기술적인 특징과 사용 방법을 넘어선 설계의 측면으로 발전하게 됩니다. 때문에 객체지향 설계, 디자인 패턴, 리팩토링, 단위 테스트와 같은 객체의 설계와 구현에 관한 여러가지 응용 기술과 지식이 요구되어집니다.

스프링은 객체를 어떻게 효과적으로 설계하고 구현하고 사용하고 이를 개선해 나갈 것인가에 대한 명쾌한 기준을 마련해줌과 동시에 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 제공합니다.

<br>

## 1.1 초난감 DAO

초난감 DAO란 여러 관심사와 책임이 하나의 클래스에 혼재되어 높은 결합도를 가지고 있는 클래스를 의미합니다. 토비의 스프링 1장에서는 이러한 초난감 DAO가 가지고 있는 문제점을 하나하나 개선해 나아갑니다. 그 과정에서 다음의 질문들에 초점을 맞춰서 생각을 해봅시다.

- 초난감 DAO 클래스 코드의 문제점은 무엇일까?
- 왜 이 코드에 문제가 많다고 하는 것일까?
- 잘 동작하는 코드를 굳이 수정하고 개선해야하는 이유는 무엇일까?
- 초난감 DAO 클래스 코드를 개선했을 때의 장점은 무엇인가?
- 당장에 얻을 수 있는 장점과 더불어 미래에 어떠한 이점을 가져다 주는가?
- 객체지향 설계 원칙과 초난감 DAO 클래스를 개선하는 것과는 어떠한 상관관계가 있는가?
- 이러한 초난감 DAO를 그대로 사용한 경우와 개선한 경우 스프링에서의 차이는 무엇인가?

<br>

## 1.2 관심사의 분리

토비의 스프링 1장에서 가장 인상깊게 읽은 부분을 꼽으라면 1.2의 관심사 분리에 나온 지문을 소개하고 싶습니다.

```
세상에는 변하는 것과 변하지 않는 것이 있다. 하지만 객체지향의 세계에서는 모든 것이 변한다.
여기서 변한다는 것은 변수나 오브젝트 필드 값이 변한다는 게 아니다. 오브젝트에 대한 설계와 이를 구현한
코드가 변한다는 뜻이다.

... 

사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 애플리케잇녀이 기반을 두고
있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변환한다. 

그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래릐 변화를 어떠헥 대비할 것인가이다.

토비의 스프링 3.1 p.61
```

책의 구문처럼 객체지향 세계에서는 모든 것이 변화합니다. 때문에 개발자가 이를 설계하고 개발할 때 가장 핵심적으로 고려해야할 사항은 바로 미래에 대한 변화를 어떻게 대비할 것인지 어떻게 확장성 있고 유지보수하기 쉬운 설계를 할 것인가 입니다.

객체지향 프로그래밍이 절차지향 프로그래밍 패러다임에 비해 초기에 조금 더 많은 번거로운 작업들을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문입니다. 

 이러한 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고 이를 자유롭고 편리하게 변경, 발전, 확장 시킬 수 있다는 것이 객체지향의 진정한 의미입니다.

 그렇다면 미래의 변화에 어떻게 대비할 것인가라는 과제가 남았는데요 이에 대한 가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것입니다. 

 어떻게 변경이 일어날 때 필요한 작업을 최소화하고 변경이 다른 곳에 문제를 잃으키지 않게 할 수 있을까요? 이것을 가능하게 해주는 것은 바로 분리와 확장을 고려한 설계입니다.

<br>

### 분리

먼저 분리의 관점에서 생각해봅시다. 변경과 발전에 대한 요청은 한번에 한가지 관심사항에 집중해서 일어나게 된다는 것을 알 수 있습니다. 하지만 문제가 되는 것은 변화는 대체로 집중된 한가지 관심에 대해서 일어나지만 그에 따른 작업은 여러 곳에서 동시다발적으로 발생해야 한다는 것에서 시작됩니다.

만약 하나의 설계나 기능을 변경하기 위해 수백 개의 코드를 수정하고 구조를 변경해야 한다면 하나의 변화를 이루기 위해서 지불해야 하는 대가가 너무나도 클 것입니다. 

떄문에 변화가 한번에 한 가지 관심에 집중되어 일어난다면 개발자가 할 일은 한 가지 관심이 한 군데에 집중할 수 있도록 하는 것입니다. 즉, 관심이 같은 것 끼리는 모으고 관심이 다른 것 끼리는 떨어지게 하는 것이 필요합니다.

이러한 관심사의 분리를 통해 관심이 같은 것 끼리는 하나의 객체 안으로 모으고 관심이 다른 것은 가능한 따로 떨어져서 영향을 주지 않도록 분리하는 것을 통해 여러 종류의 관심사를 적절하게 구분하고 같은 관심에 효과적으로 집중할 수 있게 되는 것입니다.

토비의 스프링 3.1에 나오는 `UserDao` 클래스의 관심사 분리는 다음의 과정을 거쳐서 진행됩니다.

- 데이터베이스 연결, SQL 실행, 리소스 관리에 대한 관심사를 적절하게 분리하기
- 중복된 코드를 하나의 메서드를 통해 분리
    - 데이터베이스 커넥션을 가져오는 중복된 코드를 하나의 메서드로 분리
    - 데이터베이스 연결과 관련된 부분에 변경이 일어나더라도 하나의 메서드의 코드만 수정하면 되기 때문에 변화에 유연하게 대처가 가능하다.
- 상속을 통한 확장
    - 변경될 가능성이 존재하는 데이터베이스 커넥션을 생성하는 방식을 상속을 통해 자유롭게 확장
    - 서브 클래스에서 구체적인 객체의 생성 방법을 결정하게 하는 팩토리 메서드 패턴을 적용함으로써 관심 사항이 다른 코드를 분리해내고 서로 독립적으로 변경 및 확장이 가능하다.

<br>

## 1.3 DAO의 확장

앞서서 `UserDao` 클래스를 상속을 통해 확장하였지만 상속 관계를 통한 확장은 여전히 다음과 같은 문제를 가지고 있습니다.

- 슈퍼 클래스와 서브 클래스가 긴밀한 결합을 가지고 있다.
    - 때문에 슈퍼 클래스 내부에 변경이 일어나게되면 모든 서브 클래스를 수정하거나 다시 개발해야 할 수도 있다.
- 확장된 기능의 코드를 다른 클래스에 적용할 수 없다.
    - 때문에 매번 상속을 통해 DAO 클래스들이 계속해서 만들어진다면 상속을 통해 만들어진 해당 구현코드가 매번 DAO 클래스마다 중복되서 나타날 것이다.

이러한 문제가 발생한 원인은 다음의 서로다른 변화의 성격을 고려하지 않은 확장 때문입니다

- 데이터 엑세스 로직을 어떻게 만들 것인가
- 데이터베이스 연결을 어떻게 할 것인가

때문에 관심사를 메서드를 분리한 코드를 또 다시 변화의 성격이 다른 것들을 다른 클래스로 분리해 두 개의 관심사를 독립시키면서 동시에 손쉽게 확장할 수 있도록 변경하기 위해서는 먼저 두 가지 문제를 해결해야합니다.

- 구현 클래스에서 서로다른 메서드를 제공하는 경우 구현 클래스를 변경할 경우 변화에 대한 변경사항이 여러 곳에서 동시다발적으로 발생하는 것
- 데이터베이스 커넥션을 제공하는 클래스가 어떤 것인지 구체적으로 알고있어야 하기 때문에 구현 클래스와 직접적으로 의존관계를 맺고 있는 것

<br>

### 인터페이스의 도입

이러한 문제를 해결하기 위해서는 두 개의 클래스가 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리르 만들어주는 작업이 필요합니다. 

 때문에 인터페이스를 도입하여 추상화를 통해 공통적인 성격을 뽑아내어 분리하고 구현한 클래스에 대한 구체적인 정보는 모두 감추어 이를 사용하는 측에서는 일관된 방법으로 인터페이스를 통해 접근할 수 있게 됩니다. 이러한 구조의 장점은 구체적인 구현 클래스의 변경 또는 변화가 발생하더라도 클라이언트는 이에 관심을 가지고 신경쓸 필요가 없다는 점입니다.

인터페이스를 도입했지만 여전히 남아있는 문제는 구체적인 구현 클래스와 직접적으로 의존하고 있다는 것입니다. 이러한 문제는 객체 생성에 대한 책임이라는 관심사가 여전히 클래스에 존재하기 때문입니다. 이를 해결하기 위해서는 객체 생성에 대한 책임을 클라이언트로 위임하여 구현 클래스를 선택하고 선택한 클래스의 오브젝트를 생성하는 방식을 통해서 분리할 수 있습니다.

인터페이스를 통한 추상화와 다형성을 이용한 다이나믹한 의존관계 설정, 그리고 런타임 오브젝트 의존관계를 설정하는 책임을 분리함으로써 상속을 사용했을 때 보다 더 유연하고 확장가능한 코드로 개선할 수 있었습니다. 

### 원칙과 패턴

위에서의 리팩토링 과정은 객체지향의 5가지 원칙 중 하나인 개방 폐쇄 원칙을 적극 확용하고 있습니다. 

개방 폐쇄 원칙 `OCP, Open-Closed Principle` 은 클래스나 모듈의 확장에는 열려있어야하고 변경에는 닫혀있어야 한다는 것을 의미합니다. 

즉, 이제까지 `UserDao` 클래스를 분리해오면서 데이터베이스 연결 방법이라는 기능을 유연하게 확장할 수 있으며 `UserDao` 클래스에 영향을 주지 않고 이를 확장하고 동시에 `UserDao` 는 변화에 영향을 받지 않고 유지할 수 있다고 말할 수 있습니다. 

<br>

### 결합도와 응집도

개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어 개발원리로도 설명이 가능합니다. 

응집도가 높다는 의미는 하나의 모듈, 클래스가 하나의 책임과 관심사에 집중되어있다는 의미로 불필요하거나 직접 관련이 없는 외부의 관심과 책임에 얽혀있지 않고 공통 관심사는 한 클래스에 모여있다는 것입니다.

높은 응집도의 장점은 변경이 일어날 때 모듈의 많은 부분이 동시에 변경된다는 점입니다. 때문에 모듈 전체 중 어느 부분이 바뀌고 바뀌지 않는지를 파악하고 변하는 부분으로 인해 다른 부분에 영향을 미치지 않는지 확인해야 하는 부담을 줄일 수 있습니다.

낮은 결합도는 높은 응집도 보다 더 민감한 원칙으로 책임과 관심사가 다른 객체 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것을 의미합니다. 낮은 결합도를 위해서 관계를 유지하는데 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적으로 알 필요 없게 만들어주는 것이 필요합니다.

낮은 결합도의 장점은 변화에 대응하는 속도가 높아지고 구성이 깔끔해진다는 점에 있습니다. 또한 이러한 장점들을 통해 좀 더 확장에 유연하도록 구성할 수 있게 됩니다. 

<br>

### 전략 패턴

전략 패턴은 `OCP` 의 실현과도 가장 잘 들어맞는 패턴으로 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴입니다.

즉, 인터페이스를 통해 느슨한 연관관계와 이를 통한 확장에 유연한 구조를 만드는 것이 전략 패턴의 목표입니다. 

토비의 스프링에 나오는 개선된 `UserDao` 클래스는 초기의 초난감 `UserDao` 에서 시작하여 관심사를 분리하고 인터페이스를 이용한 느슨한 연관관계와 연관관계 설정에 대한 책임을 외부로 분리함을 통해서 `OCP` 원칙을 잘 따르고 결합도가 낮고 응집도가 높으며 전략패턴을 잘 활용한 사례로 볼 수 있습니다. 

 `UserDao` 의 기능은 그대로지만 내부 구현을 변경함을 통해 좀 더 변화와 확장에 유연하고 유지보수하기 쉬운 구조로 변경할 수 있었습니다.

## 1.4 제어의 역전 (IoC)

기존의 인터페이스를 이용한 확장 방식에서 클라이언트 코드에 객체 생성과 구체적인 구현클래스를 결정하는 책임을 위임하는 것을 통해 확장에 유연한 구조를 만들 수 있었습니다.

하지만 이 방법의 문제는 또 다시 클라이언트 측면에서 보면 클라이언트 코드가 가지고 있는 책임 이외에도 구현 클래스를 결정하는 책임을 가지고 있다는 것입니다. 때문에 지금까지 적용해왔던 분리를 통해 이를 또 한번 분리시켜줄 필요성이 존재합니다.

<br>

### 팩토리

팩토리는 객체 생성의 방법을 결정하고 그렇게 만들어진 객체를 돌려주는 역할을 가진 클래스를 의미합니다. 팩토리 클래스는 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용되어집니다. 

때문에 위의 코드에서 팩토리를 적용하여 객체 생성의 책임을 분리함으로써 컴포넌트의 역할과 애플리케이션 구조를 결정하는 객체를 분리할 수 있습니다. 

<br>

### 제어의 역전 (IoC, Inversion of Control)

제어의 역전은 간단하게 프로그램의제어 흐름 구조가 뒤바뀌는 것을 의미합니다. 일반적으로 프로그램의 흐름은 다음과 같이 이루어집니다.

- `main()` 메서드와 같이 프로그램의 엔트리 포인트에서 사용할 객체를 결정하고
- 결정된 객체를 생성하고
- 만들어진 객체의 메서드를 호출하고
- 객체의 메서드 안에서 다음에 사용할 것들을 결정하고 호출하는 식의 작업의 반복

이런 구조에서 객체는 프로그램 흐름을 결정하거나 사용할 객체를 구성하는 작업에 능동적으로 참여합니다. 초기의 테스트코드 예제를 보면  `UserDao` 클래스의 객체를 직접 생성하고 만들어진 오브젝트의 메서드를 사용하고 `UserDao` 클래스 또한 자신이 사용할 구체적인 데이터베이스 연결에 대한 구현 클래스를 결정하여 필요한 시점에 생성하고 사용합니다.

즉, 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조입니다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것을 의미합니다. 제어의 역전에서는 객체가 자신이 사용할 오브젝트를 스스로 선택하지 않습니다. 또한 객체 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없습니다. 

이런 것이 가능한 이유는 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이빈다. 프로그램의 시작을 담당하는 `main()` 함수와 같은 엔트리 포인트를 제외하면 모든 객체는 위임받은 제어 권한을 갖는 특별한 객체에 의해 결정되고 만들어지게 됩니다.

사실 제어의 역전이란 개념은 서블릿과 서블릿 컨테이너, 템플릿 메서드 패턴, 프레임워크 등 다양한 부분에서 이미 사용되고 있습니다. 

<br>

### 라이브러리와 프레임워크

프레임워크는 제어의 역전이 적용된 대표적이 기술입니다. 프레임워크가 어떤 것인지 이해하기 위해서는 먼저 라이브러리와 프레임워크가 어떻게 다른지를 알아야 합니다.

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어합니다. 단지 동작하는 중간에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐입니다.

반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용되는 형태를 가지고 있습니다. 프레임 워크 위에 개발한 클래스를 등록하고 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만든 방식입니다. 

즉, 이 둘의 가장 큰 차이는 제어권이 어디에 있는지 인데 프레임워크에는 분명한 제어의 역전 개념이 적용된 것이어야만 합니다. 

앞서 팩토리를 통해 만든 구조에서도 제어의 역전이 적용되어 있습니다. `UserDao` 클래스도 팩토리에 의해 수동적으로 만들어지고 사용할 객체들도 팩토리가 공급해주는 것을 수동적으로 사용할 뿐입니다. 

자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장하는 구조로 만들기 위해 팩토리를 도입했던 과정이 바로 `IoC` 를 적용하는 작업으로 이를 통해 설계가 깔끔해지고 유연한 확장이 가능한 구조가 가능해졌습니다. 

<br>

## 1.5 스프링의 IoC

 대표적인 `IoC` 컨테이너라고 불리는 스프링에서 가장 핵심적인 기능을 담당하는 것은 애플리케이션 컨텍스트라고 불리는 스프링 `IoC` 컨테이너 입니다. 

스프링에서는 스프링이 제어권을 직접 가지고 관계를 부여하는 객체를 스프링 빈이라고 부릅니다. 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 `IoC` 가 적용된 객체를 가리키는 단어입니다.

스프링에서 제어를 담당하는 `IoC` 객체를 빈 팩토리라고 하며 이를 확장한 애플리케이션 컨텍스트를 주로 사용합니다. 애플리케이션 컨텍스트는 별도의 정보를 참고하여 빈을 생성하고 관계를 설정하는 등의 제어 작업을 총괄합니다. 

애플리케이션 컨텍스트에서 사용할 설정정보르를 담당하는 클래스는 `@Configuration` 이라는 어노테이션을 붙이고 메서드에는 `@Bean` 이라는 어노테이션을 붙여서 이를 스프링이 빈 팩토리를 위한 객체 설정을 담당하는 클래스라고 인식할 수 있습니다. 

<br>

### 애플리케이션 컨텍스트의 동작방식

팩토리가 특정 클래스에 대한 객체를 생성하고 관계를 맺어주는 제한적인 역할을 하는 반면에 애플리케이션 컨텍스트는 애플리케이션에서 `IoC` 를 적용해서 관리할 모든 객체에 대한 생성과 관계설정을 담당합니다. 

뿐만아니라 애플리케이션 컨텍스트에는 객체 생성 및 관계를 맺어주는 코드가 직접적으로 존재하지 않고 별도의 설정정보를 통해 다음과 같은 과정으로 객체의 생성과 관리에 대한 정보들을 얻습니다.

- `@Configuration` 및 `@Bean` 어노테이션이 붙은 클래스를 스캔하여 빈 설정 정보를 통해 빈 목록을 생성합니다.
- 클라이언트의 요청에 의해 빈 목록에 요청한 이름이 있는지 찾고 있다면 이를 찾고 생성하는 메서드를 호출해 이를 전달합니다.

애플리케이션 컨텍스트를 통해 기존의 팩토리의 기능을 그대로 적용하면서도 범용적이고 유연한 방법으로 `IoC` 기능을 확장할 수 있습니다. 뿐만아니라 팩토리를 사용할 때와 비교하여 다음의 장점들을 얻을 수 있습니다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
    - 클라이언트가 필요한 객체를 가져오려면 어떠한 팩토리 클래스를 사용해야 할지 알고 필요할 때마다 팩토리 오브젝트를 생성하는 번거로움이 있지만 애플리케이션 컨텍스트를 사용하면 일관된 방식으로 원하는 객체를 가져올 수 있습니다.
- 애플리케이션 컨텍스트는 종합 `IoC` 서비스를 제공한다.
    - 애플리케이션 컨텍스트의 역할을 단지 객체 생성과 관계 설정만이 아니라 객체가 만들어지는 방식, 시점, 전략을 다르게 가져갈 수도 있으며 자동생성, 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 객체를 효과적으로 사용할 수 있는 다양한 기능을 제공한다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
    - 애플리케이션 컨텍스트는 빈의 이름 뿐만 아니라, 타입 또는 특별한 어노테이션로 설정되어 있는 빈을 찾을 수 있는 기능을 제공한다.
