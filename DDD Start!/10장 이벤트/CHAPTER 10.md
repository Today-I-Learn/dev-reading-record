## 시스템 간 강결합의 문제

쇼핑몰에서 구매를 취소하려면 환불을 처리해야 한다. 이때 환불 기능을 실행하려면 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행해야 한다. 또는 응용 서비스에서 환불 기능을 실행해야 한다. 보통 결제 시스템은 외부에 존재하므로 외부의 환불 시스템 서비스를 호출하는데, 이때 두 가지 문제가 발생한다.

- 외부 서비스가 정상이 아닐 경우 트랜잭션 처리
- 성능

추가로 설계상 문제가 나타날 수 있다.

위와 같은 문제들이 발생하는 이유는 BOUNEDED CONTEXT간의 강결합 때문이다. 이런 강한 결합을 없앨 수 있는 방법이 바로 **이벤트**를 사용하는 것이다. 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.

### 이벤트 개요

이벤트

- '과거에 벌어진 어떤 것'을 의미한다.
- 이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다.
- 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

보통 '~할 때', '~가 발생하면', '만약 ~하면' 과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있다.

### 이벤트 관련 구성 요소

![ddd_start_10_01](https://user-images.githubusercontent.com/40006670/137708572-982b5792-4412-4fef-a18e-d1c1602b7343.png)

- 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생한다.
- 이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 반응한다. 이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.
- 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처이다. 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다. 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.

### 이벤트의 구성

- 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
    - 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트 이름에는 **과거 시제**를 사용한다.
- 이벤트 발생 시간
- 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보
    - 이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 최소한의 데이터를 담아야 한다. 이 것이 부족할 경우 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다.

### 이벤트 용도

- 트리거
    - 도메인의 상태가 바뀔 때 다른 후처리를 해야 할 경우 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
- 데이터 동기화
    - 도메인은 이벤트를 발생시키고 이벤트 핸들러는 정보를 동기화시킨다.

### 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.
- 기능 확장이 용이하다. 기능을 확장해도 도메인 로직은 수정할 필요가 없다.

### 이벤트, 핸들러, 디스패처 구현

- 이벤트 클래스
- 이벤트 핸들러
- 이벤트

### 이벤트 클래스

- 이벤트 자체를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용한다. 
주의해야 할 점은 과거에 벌어진 상태 변화나 사건을 의미하므로 이름을 결정할 때는 과거 시제를 사용해야 한다는 점이다.
- 이벤트 클래스는 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함해야 한다.
- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있다.

### EventHandler 인터페이스

- 이벤트 핸들러를 위한 상위 인터페이스이다.
- EventHandler 인터페이스를 상속받는 클래슨느 `handle()` 메서드를 이용해서 필요한 기능을 구현하면 된다.
- `canHandle()` 메서드는 핸들러가 이벤트를 처리할 수 있는지 여부를 검사한다.

### 이벤트 디스패처인 Events 구현

- 도메인을 사용하는 응용 서비스는 이벤트를 받아 처리할 핸들러를 `Events.handle()`로 등록하고, 도메인 기능을 실행한다.
- 이벤트를 발생시킬 때는 `Events.raise()`메서드를 사용한다.
- Events는 핸들러 목록을 유지하기 위해 [ThreadLocal](https://javacan.tistory.com/entry/ThreadLocalUsage) 변수를 사용한다. 톰캣과 같은 웹 애플리케이션 서버는 스레드를 재사용하므로 THreadLocal에 보관한 값을 제거하지 않으면 기대했던 것과 다르게 동작할 수 있다.

### 이벤트 처리 흐름

![ddd_start_10_02](https://user-images.githubusercontent.com/40006670/137708597-e4a4b937-675b-4cef-b81d-154f7dbd3a12.png)


1. 이벤트 처리에 필요한 이벤트 핸들러 생성
2. 이벤트 발생 전에 이벤트 핸들러를 `Events.handle()` 메서드를 이용해서 등록
3. 이벤트를 발생하는 도메인 기능 실행
4. 도메인은 `Events.raise()`를 이용해서 이벤트 발생
5. `Events.raise()` 는 등록된 핸들러의 `canHandle()`을 이용해서 이벤트를 처리할 수 있는지 확인
6. 핸들러가 이벤트를 처리할 수 있다면 `handle()`메서드를 이용해서 이벤트 처리
7. `Events.raise()` 실행을 끝내고 리턴
8. 도메인 기능 실행을 끝내고 리턴
9. `Events.reset()`을 이용해 ThreadLocal을 초기화

코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 핸들러의 `handle()`이 실행되는 것을 알 수 있다. 즉, 도메인의 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

### AOP를 이용한 Events.reset() 실행

응용 서비스가 끝나면 ThreadLocal에 등록된 핸들러 목록을 초기화하기 위해 `Events.reset()` 메서드를 실행하는데 이는 중복이 발생한다. 따라서 AOP를 이용해서 `Events.reset()`을 실행할 수 있다.

### 동기 이벤트 처리 문제

외부 시스템이 느려진다면 이벤트를 발생시키는 메서드도 함께 느려진다. 이 것은 외부 시스템의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다는 것을 의미한다. 성능 저하뿐만 아니라 트랜잭션도 문제가 된다. 

위와 같은 문제를 해결하는 방법 중 하나가 이벤트를 비동기로 처리하는 것이다.

### 비동기 이벤트 처리

- 로컬 핸들러를 비동기로 실행
- 메시지 큐 사용
- 이벤트 저장소와 이벤트 포워더 사용
- 이벤트 저장소와 이벤트 제공 API 사용

### 로컬 핸들러의 비동기 실행

- 이벤트 핸들러를 별도 스레드로 실행하는 것이다.
- `ExecutorService`를 이용하여 비동기를 실행한다. executor는 내부적으로 사용하는 스레드 풀을 이용해서 인자로 전달받은 람다식을 실행하므로 결과적으로 `raise()` 메서드를 실행하는 스레드가 아닌 다른 스레드를 이용해서 이벤트 핸들러를 비동기로 실행하게 된다.
    - `executor.submit(() -> handler.handle(event));`
- 별도 스레드로 이벤트 핸들러를 사용한다는 것은 `raise()`메서드와 관련된 트랜잭션 범위에 이벤트 핸들러 실행이 묶이지 않는다는 것을 의미한다.
- 별도 스레드를 이용해서 이벤트 핸들러를 실행하면 이벤트 발생 코드와 같은 트랜잭션 범위에 묶을 수 없기 때문에 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리해서는 안된다.

> 스프링의 트랜잭션 관리자는 일반적으로 스레드를 이용해서 트랜잭션을 전파한다. 물론, 스레드가 아닌 다른 방식을 이용해서 트랜잭션을 전파할 수 있지만 일반적으로 사용하는 트랜잭션 관리자는 스레드를 이용해서 트랜잭션을 전파한다. 이런 이유로 다른 스레드에서 실행되는 두 메서드는 서로 다른 트랜잭션을 사용하게 된다.
> 

### 메시징 시스템을 이용한 비동기 구현

![99918450-400f8e80-2d5a-11eb-9b31-b7d4608989aa](https://user-images.githubusercontent.com/40006670/137708634-cbea739c-2ee9-4a9f-8ae4-a9afeabe1b04.png)


1. 이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시지 큐에 보낸다. 
2. 메시지 큐는 이벤트를 메시지 리스너에 전달하고. 메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트를 처리한다. 
이때 이벤트를 메시지 큐에 저장하는 과정과 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다.
- 필요하다면 이벤트를 발생하는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 하는데 이를 위해서는 글로벌 트랜잭션이 필요하다
    - 글로벌 트랜잭션을 사용하면 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점이 있지만 전체 성능이 떨어지는 단점도 있다.
- 메시지 큐를 사용하면 보통 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다. 이는 Java의 경우 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다는 것을 의미한다. 동일 JVM에서 비동기 처리를 위해 메시지 큐를 사용하는 것은 시스템을 복잡하게 만들뿐이다.
- RabbitMQ처럼 많이 사용되는 메시징 시스템은 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다. 또한 다양한 개발 언어와 통신 프로토콜을 지원하고 있다.

### 이벤트 저장소를 이용한 비동기 처리

이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 것이다.

![99919198-58ce7300-2d5f-11eb-897a-d5f5de43a851](https://user-images.githubusercontent.com/40006670/137708652-52869cf7-1003-4db9-80e3-b2a2b1faf013.png)


1. 이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장한다.
2. 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다.
3. 포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리된다.

이 방식은 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다. 즉, 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.

API 방식과 포워더 방식의 차이점은 이벤트를 전달하는 방식에 있다. 포워더 방식에서는 포워더를 이용해서 이벤트를 외부에 전달하는 방식이라면, API 방식에서는 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져오는 방식이다. 

- 포워더 방식
    - 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다.
- API 방식
    - 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.

### 이벤트 적용 시 추가 고려사항

1. 이벤트 소스를 EventEntry에 추가할 지 여부
2. 포워더에서 전송 실패를 얼마나 허용할 것인지
    - 포워드를 구현할 때는 실패한 이벤트의 재전송 횟수에 제한을 두어야 한다.
3. 이벤트 손실
    - 이벤트 저장소를 사용하는 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장된다는 것을 보장할 수 있다. 반면에 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.
4. 이벤트 순서
    - 이벤트를 발생 순서대로 외부 시스템에 전달해야 할 경우 이벤트 저장소를 사용하는 것이 좋다. 이벤트 저장소는 일단 저장소에 이벤트를 발생 순서대로 저장하고, 그 순서대로 이벤트 목록을 제공하기 때문이다. 반면에 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수도 있다.
5. 이벤트 재처리
    - 동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할 지 결정해야 한다.
