# JPA를 이용한 리포지터리 구현

- 애그리거트를 어떤 저장소에 저장하느냐에 따라서 리포지터리를 구현하는 방법이 다르다.
- 도메인 모델과 리포지터리를 구현할 때 선호하는 기술 중 하나는 JPA를 들 수 있따.

## 모듈 위치

- 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고 리포지터리를 구현한 클래스는 인프라 영역에 속한다.
- DIP 따라서 리포지터리 구현 클래스는 인프라 영역에 위치하게 된다.
- 리포지터리 구현 클래스를 도메인의 하위 패키지에 위치시키는 경우도 있지만 좋은 설계 원칙은 아니며 가능하면 리포지터리 구현 클래스를 인프라 영역에 위치시켜 인프라에 대한 의존을 낮춰야한다.

## 리포지터리 기본 기능 구현

- 리포지터리의 기본 기능은 아이디로 애그리거트를 조회하는 것과 애그리거트를 저장하는 것이다.
- 인터페이스는 애그리거트 루트를 기준으로 작성한다.

삭제 요구사항이 있더라도 데이터를 실제로 삭제하는 경우는 많지 않다.
관리자 기능에서 삭제한 데이터까지 조회하거나 데이터를 복구하기 위해 일정 기간 보관해야하는 경우도 있기 때문에 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기 보다는 삭제 플래그를 이용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현한다.

# 매핑 구현

## 앤티티와 밸류 기본 매핑 구현

하이버네이트는 데이터베이스에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문에 기본 생성자를 반드시 추가해야한다.

## 필드 접근 방식 사용

- 앤티티에 프로퍼티를 위한 `get` , `set` 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
- 특히 `set` 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수있다.
- 엔티티가 객체로서 제 역할을 하려면 외부에 `set` 메서드 대신 의도가 잘 드러나는 기능을 제공해야한다.
    - ex. 상태 변경을 위한 `setState()` 메서드 보다는 주문 취소를 위한 `cancel()` 메서드가 도메인을 더 잘 표현한다.
- 불변 객체로 설계할 떄 뿐만 아니라 JPA의 구현 방식 떄문에서라도 공개적인 `set` 메서드를 추가하는 것은 좋지않다.
- 엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 `get` , `set` 메서드를 구현하지 말아야한다.

## AttributeConverter를 이용한 밸류 매핑 처리

- 두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개의 컬럼에 매핑해야하는 경우 `@Embeddable` 로는 처리할 수 없다.
- JPA 2.0 이하 버전에서는 이를 처리하기 위해 컬럼과 매핑하기 위한 프로퍼티를 따로 추가하고 `get` , `set` 메서드에서 실제 밸류 타입과 변환 처리를 수행해야 했다.
- JPA 2.1 버전부터는 데이터베이스 컬럼과 밸류 사이의 변환 코드를 모델에 구현하지 않아도 `AttributeConverter` 를 이용해서 처리할 수 있다.

## 밸류 컬렉션 : 별도 테이블 매핑

- 주문 엔티티는 한 개 이상의 주문 리스트를 가질 수 있으며 주문 리스트에 순서가 있다면 `List` 타입을 이용해서 주문 리스트 타입의 컬렉션을 프로퍼티로 가지게 된다.

```java
public class Order {

	private List<OrderLine> orderLines;
}
```

- 밸류 타입의 컬렉션은 별도 테이블에 보관하며 밸류 컬렉션을 저장하는 테이블은 외부키를 이용해서 엔티티에 해당하는 테이블을 참조한다.
- 외부키는 컬렉션이 속할 엔티티를 의미하며 `List` 타입의 컬렉션은 인덱스 값도 필요하기 때문에 인덱스 값을 저장하기 위한 별도의 컬럼도 존재한다.
- 밸류 컬렉션을 별도 테이블로 매핑할 떄는 `@ElementCollection` 과 `@CollectionTable` 을 함꼐 사용하며 인덱스 값을 저장하기 위해서 `@OrderColumn` 을 이용할 수 있다.

```java
@Entity
public class Order {

	@ElementCollection
	@CollectionTable(name = "order_line",
									joinColumns = @JoinColumn(name = "order_number"))
	@OrderColumn(name = "line_idx")
	private List<OrderLine> orderLines;
}
```

## 밸류 컬렉션 : 한 개 컬럼 매핑

# 애그리거트 로딩 전략

- JPA매핑을 설정할 떄 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.
- 즉, 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 함을 의미한다.

## 애그리거트와 즉시로딩

- 조회 시점에서 애그리거트를 완전한 로딩 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면된다.
- 즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함꼐 로딩할 수 있다는 장점이 있지만 오히려 단점으로 작용할 경우가 많다.
- 특히 컬렉션 로딩 전략을 즉시 로딩으로 설정하는 경우가 문제가되는데 이 경우 모든 데이터를 불러오기 위해 테이블을 조인한 쿼리가 카타시안 조인을 사용해 결과에 중복을 발생시킬 수 있다.
- 하이버네이트가 중복된 데이터를 적절하게 제거해서 변환해주지만 애그리거트가 커지면 문제가 될 수 있다.
- 실제 필요한 데이터보다 훨씬 많은 데이터를 조회하면서 조회 성능이 오히려 나빠지는 상황이 발생한다.

## 애그리거트와 지연로딩

- 애그리거트는 개념적으로는 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 모든 객체를 로딩해야하는 것은 아니다.
- 애그리거트가 완전해야하는 이유는 다음과 같은 이유로 생각해볼 수 있다.
    - 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야한다.
    - 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하다.
- 두 번째는 별도의 조회 전용 기능을 구현하는 방식을 사용하는 것이 유리할 떄가 많기 때문에 애그리거트의 완전한 로딩과 관련된 문제는 상태 변경과 더 관련이있다.
- 상태 변경 기능을 위해서 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없으며 JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 떄문에 실제로 상태를 변경하는 시점에 필요한 구성 요소만 로딩해도 문제가 되지 않는다.

# 애그리거트의 영속성 전파

- 애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때 뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다.
    - 저장 메서드는 애그리거트 루트만 저장하면 안되고 애그리거트에 속한 모든 객체를 저장해야한다.
    - 삭제 메서드는 애그리거트 루트 뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.

# 식별자 생성 기능

- 식별자 생성은 사용자 직접 생성, 도메인 로직으로 생성, 데이터베이스를 이용한 일련번호 사용 등의 방법으로 생성할 수 있다.
- 이메일 주소처럼 사용자가 직접 식별자를 입력하는 경우 식별자 생성 주체가 사용자이기 때문에 도메인 영역에 식별자 생성 기능을 구현할 필요는 없다.
- 식별자 생성 규칙이 있는 경우 엔티티를 생성할 때 이미 생성한 식별자를 전달하기 때문에 엔티티가 직접 이러한 기능을 제공하기 보다는 별도의 서비스로 식별자 생성 기능을 분리해야한다.
- 식별자 생성 규칙은 도메인 규칙이기 떄문에 도메인 영역에 기능을 위치시켜야한다.
- 식별자 생성으로 데이터베이스의 자동 증가 컬럼을 사용할 경우 데이터베이스의 `insert` 쿼리를 실행해야 식별자가 생성되기 때문에 도메인 객체를 리포지터리에 저장할 때 식별자가 생성된다.
- 즉, 도메인 생성 시점에는 식별자를 알 수 없고 도메인을 저장할 뒤에 식별자를 구별할 수 있음을 의미한다.
