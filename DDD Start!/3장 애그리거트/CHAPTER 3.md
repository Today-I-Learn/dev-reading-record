# 3장 애그리거트

- 애그리거트
- 애그리거트 루트와 역할
- 애그리거트와 리포지터리
- ID를 이용한 애그리거트 참조

## 애그리거트

애그리거트를 통해 복잡한 도메인을 이용하고 관리하기 쉬운 단위로 만들수 있다.

수많은 객체를 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.

애그리거트를 사용함으로써 모델 간의 관계를 개별 모델 수준뿐만 아니라 상위 수준에서도 이해할 수 있다.

애그리거트는 복잡한 도메인을 단순한 구조로 만들어주고 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력을 줄여준다.

애그리거트는 독립된 객체 군이며, 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

또한, 애그리거트의 경계를 설정할 때 기본이되는 것은 도메인 규칙과 요구사항이다.

## 애그리거트 루트

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다.

애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.

### 도메인 규칙과 일관성

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 유지하는 것이다.

이를 위해, 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현해야 한다.

또한, 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.

만일 직접 변경하게 되면 DB 테이블에서 직접 데이터를 수정하는 것과 같은 결과를 발생시켜 데이터의 일관성이 깨지기 때문이다.

애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기 위해 아래 2가지를 적용해야한다.

1. 단순히 필드를 변경하는 `set` 메서드를 `public` 범위로 만들지 않는다.
2. 벨류 타입은 불변으로 구현한다.

공개 `set` 메서드를 사용하지 않게 되면 의미가 드러나는 메서드를 사용해서 구현할 가능성이 높아지고, 밸류 객체가 불변이면 밸류 객체의 값을 변경하기 위해 새로운 밸류 객체를 할당해야 한다.

### 트랜잭션 범위

트랜잭션 범위는 작을수록 좋다.

다수의 테이블에 수정이 필요한 경우 잠금의 대상이 많아지고, 이것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하며 전체적인 성능을 떨어뜨릴수 있다.

또한, 한 트랜잭션에서는 한 애그리거트만 수정하는 것이 좋다.

애그리거트는 서로 최대한 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게 된다.

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.

리포지터리는 적어도 `save`, `findById` 메서드를 제공하여 애그리거트를 저장하고, 사용할 수 있어야한다.

또한 애그리거트르 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.

## ID를 이용한 애그리거트 참조

애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트 루트를 참조한다는 것과 같다.

필드 또는 `get` 메서드를 이용한 애그리거트 참조를 사용하면 `편한 탐색 오용`, `성능에 대한 고민`, `확장 어려움` 이라는 문제를 야기할 수 있다.

`편한 탐색 오용`은 애그리거트 내부에서 다른 애그리거트 객체에 접근이 쉽고, 이런 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지게 된다.

한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.

`성능에 대한 고민`은 JPA 를 사용할 경우 지연로딩과 즉시로딩중 어떤 방식을 선택할지에 대한 다양한 경우의 수를 고려해서 전략을 결정해야 한다.

`확장 어려움`은 추후 도메인별로 시스템을 분리하여 서로 다른 종류의 DB를 사용하게 된다면, 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA 와 같은 단일 기술을 사용할 수 없음을 의미한다.

이러한 문제들을 해결하기 위한 방법이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.

ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.
 
## 애그리거트 간 집합 연관

개념적으로는 애그리거트 간에 `1:N` 연관이 있더라도 성능상의 문제 때문에 애그리거트 간의 `1:N` 연관을 실제 구현에 반영하는 경우는 드물다.

`M:N` 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.

예를들어 상품이 여러 카테고리에 속할 수 있다고 가정하면 카테고리와 상품은 `M:N`이고 실제 요구사항을 고려해서 구현에 포함시킬지 여부를 결정해야한다.

요구사항을 통해 카테고리에서 상품으로의 집한 연관은 필요하지 않다면, 개념적으로는 상품과 카테고리의 양방향 `M:N` 연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단방향 `M:N` 연관만 적용하면 된다.

또한 `M:N` 연관을 `RDBMS`를 이용해 구현하는 경우에는 조인 테이블을 사용한다.

## 애그리거트를 팩토리로 사용하기

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해볼 필요가 있다.