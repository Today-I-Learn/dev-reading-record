# 표현 영역과 응용 영역

- 도메인이 제 기능을 하려면 클라이언트와 도메인을 연결해주는 매개체가 필요한데 표현 영역과 응용 영역이 이에 해당한다.

<br>

## 표현 영역과 응용 영역의 역할

- 표현 영역은 클라이언트의 요청을 해석한다.
    - 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용해서 사용자가 어떠한 기능을 실행하고 싶어하는지를 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.
- 응용 영역은 실제 사용자가 원하는 기능을 제공한다.
    - 응용 서비스는 기능을 실행하는데 필요한 입력값을 메서드 파라미터로 전달받고 실행 결과를 반환한다.

<br>

# 응용 서비스의 역할

- 응용 서비스는 클라이언트가 요청한 기능을 실행하는데 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고 이를 이용한다.
- 표현 영역의 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해주는 파사드의 역할을 수행한다.
- 응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 단순한 형태를 가지며 만약 응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직을 일부를 구현하고있을 가능성이 높다.
- 응용 서비스의 또 다른 중요한 역할은 트랜잭션 처리이다.
    - 응용 서비스는 도메인 상태 변경을 트랜잭션으로 처리해야 한다.
    - 만약 응용 서비스의 메서드가 트랜잭션 내에서 실행되지 않는다면 데이터의 일관성이 깨지게된다.

<br>

## 도메인 로직을 응용 서비스에서 구현하면 안되는 이유

- 도메인 로직을 도메인 영역과 응용 서비스에서 분산해서 구현하면 코드의 품질에 문제가 발생하게 된다.
- 코드의 응집성이 떨어진다.
    - 도메인 데이터와 이를 조작하는 도메인 로직이 서로 다른 영역에 위치한다는 것은 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 의미한다.
- 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다, 즉 중복이 발생할 가능성이 존재한다.
    - 코드의 중복을 막기 위해서 응용 서비스 영역에 별도의 보조 클래스를 만들 수 있지만 애초에 도메인 영역에 이를 구현했다면 응용 서비스는 그 기능을 사용하기만 하면 된다.
- 결국 이러한 단점들은 코드의 변경을 어렵게 만들며 소프트웨어의 중요한 경쟁 요소인 변경 용이성을 낮추고 소프트웨어의 가치를 저하시킨다.

<br>

# 응용 서비스의 구현

- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역하을 하는데 이는 파사드와 같은 역할을 한다.

<br>

## 응용 서비스의 크기

- 응용 서비스를 구현할 때는 다음과 같은 두 가지 선택지 사이에서 고민을 하게 된다.
    - 하나의 응용 서비스 클래스에 도메인의 모든 기능을 구현하기
    - 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
- 하나의 응용 서비스 클래스에서 모든 기능을 구현하는 경우에는 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.
    - 하지만 클래스의 크기가 커진다는 것이 단점으로 작용하는데 즉, 클래스의 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 위치할 가능성이 높아짐을 의미한다.
    - 결과적으로 관련 없는 코드가 뒤섞여 코드를 이해하기 어려워질 수 있으며 결국 이러한 문제점은 코드의 품질을 낮추는 결과를 초래한다.
- 구분되는 기능별로 서비스 클래스를 구현하는 방식은 하나의 응용 서비스 클래스에서 1~3개 사이의 기능을 구현한다.
    - 이 방식을 사용하면 클래스의 개수는 많아지지만 하나의 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드의 품질을 일정 수준으로 유지할 수 있다는 장점이 존재한다.
    - 또한 각 클래스별로 필요한 의존 객체만 포함하기 때문에 다른 기능을 구현한 코드에 영향을 받지 않는다.
    - 각 기능마다 동일한 로직을 구현한 경우 여러 클래스에 동일한 코드를 구현해서 중복이 발생할 가능성이 존재하는데 이는 공통 로직을 구현하는 별도의 클래스를 이용하면 이를 방지할 수 있다.

<br>

```java
public final class MemberServiceHelper {
	public static Member findExistingMember(String memberId) {
		Member memeber = memberRepository.findById(memberId);
		if(member == null) {
			throw new NoMemberException(memberId);
		}
		return member;
	}
}
```

<br>

## 응용 서비스의 인터페이스와 클래스

- 응용 서비스를 구현할 때 논쟁이 될만 한 것은 인터페이스가 필요한지 여부이다.
- 인터페이스가 필요한 몇가지 상황이 있는데 그 중 하나는 구현 클래스가 여러개인 경우이다.
- 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야할 경우에 인터페이스를 유용하게 사용할 수 있다.
- 하지만 응용 서비스에서 런타임에 이를 교체하는 경우는 거의 없을 뿐더러 하나의 응용 서비스의 구현 클래스가 두 개 이상인 경우도 매우 드물다.
- 이러한 이유에서 인터페이스와 클래스를 따로 구현하게되면 소스 파일만 많아지게되고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 결과를 낳게된다.
- 따라서 인터페이스가 명화갛게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것은 좋은 설계라고 볼 수 없다.

<br>

### 테스트 주도 개발과 인터페이스

- TDD를 이용해서 표현 영역부터 개발을 시작한다면 미리 응용 서비스를 구현할 수 없기 때문에 응용 서비스의 인터페이스부터 작성하게 될 것이다.
- 표현 영역이 아닌 도메인 영역이나 응용 영역의 개발을 먼저 시작하면 응용 클래스가 먼저 만들어진다.
- 이렇게 되면 표현 영역의 단위 테스트를 위해 응용 서비스의 가짜 객체가 필요한데 이를 위해서 인터페이스를 추가할 수도 있다.
- Mockito와 같은 테스트 도구는 클래스에 대해서도 테스트용 Mock 객체를 만들수 있도록 도와주기 때문에 서비스에 대한 인터페이스 없이도 표현 영역을 테스트할 수 있다.
- 결과적으로 이러한 도구들은 응용 서비스에 대한 인터페이스 필요성을 약화시켜준다.

<br>

## 메서드 파라미터와 값 리턴

- 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터를 통해 전달받아야 한다.
- 이 때 메서드는 각각의 값을 개별 파라미터로 받을수도 있고 별도의 데이터 클래스를 만들어서 전달받을 수도 있다.
- 표현 영역에서는 필요에 따라 응용 서비스에서 처리한 결과 값이 필요한 경우가 있는데 이 때 응용 영역에서는 애그리거트 객체를 그대로 리턴할 수도 있다.
- 애그리거트 자체를 리턴하면 코드를 작성하는 것은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게되며 이러한 기능 실행 로직의 분산은 코드의 응집도를 낮추는 원인이 된다.
- 때문에 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.

<br>

## 표현 영역에 의존하지 않기

- 응용 서비스의 파라미터 타입을 결정할 때 중요한 것은 HttpServeletRequest, HttpServeletResponse 등의  표현 영역에 해당하는 객체를 파라미터로 전달하면 안된다는 것이다.
- 이는 응용 서비스에서 표현 영역에 대한 의존이 발생하는 원인이 되며 응용 서비스만 단독으로 테스트하기 어려워지는 결과로 이어지게된다.
- 게다가 표현 영역의 구현이 변경됨에 따라서 의존하고 있는 응용 서비스의 구현도 함께 변경해야하는 문제가 발생하게 된다.
- 더욱 심각한 문제는 응용 서비스가 세션 인증과 관리 등의 표현 영역의 역할까지 대신하는 상황이 발생할 수 있다는 것이다.
- 즉, 표현 영역의 응집도가 깨지게 되어 결과적으로 표현 영역 코드만으로는 표현 영역의 상태가 어떻게 변경되는지 이해하고 관리하기 어려워지고 코드를 유지보수하는 비용을 증가시키게 된다.
- 이러한 문제가 발생하지 않기 위해서는 철저하게 응용 서비스가 표현 영역의 기술을 사용하지 않도록 해야하며, 이를 위한 가장 쉬운 방법은 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 기술을 사용하지 않는 것이다.

<br>

## 도메인 이벤트 처리하기

- 응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다.
- 이벤트는 도메인에서 발생한 상태 변경을 의미하며 암호 변경, 주문 취소 등이 이벤트가 될 수 있다.
- 이벤트를 사용하면 코드가 다소 복잡해지는 대신에 도메인 간ㅇ의 의존성이나 외부 시스템에 대한 의존성을 낮춰주는 장점을 얻을 수 있다.

<br>

# 표현 영역

- 표현 영역의 책임은 크게 다음과 같다.
- 사용자가 시스템을 사용할 수 있는 화면상의 흐름을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

<br>

# 값 검증하기

- 값에 대한 검증은 표현 영역과 응용 서비스 영역 두 곳에서 모두 수행할 수 있다.
- 원칙적으로는 모든 값에 대한 검증은 응용 서비스에서 처리하는데 예를들어 회원 가입을 처리하는 응용 서비스는 파라미터로 전달받은 값이 올바른지 검사해야한다.
- 응용 서비스에서 값을 검증하는 로직을 사용하는 경우 폼에 에러 메세지를 보여주기 위해서 표현 계층에서는 다음과 같은 번잡한 코드를 작성해야 한다.

<br>

```java
@Controller
public class MemberController {

	@RequestMapping
	public String join(JoinRequest joinRequest, Errors errors) {
		try {
			joinService.join(joinRequest);
			return successView;
		} catch(EmptyPropertyException e) {
			errors.rejectValue(e.getPropertyName(), "empty");
			return formView;
		} catch(InvalidPropertyException e) {
			errors.rejectValue(e.getPropertyName(), "invalid");
			return formView;
		} catch(DuplicatedIdException e) {
			errors.rejectValue(e.getProepertyName(), "duplicate");
			return formView;
		}
	}
}
```

<br>

- 응용 서비스에서 각 값이 존재하는지 형식이 올바른지 확인할 목적으로 익셉션을 사용할 때의 문제점은 사용자에게 좋지 않은 경험을 제공한다는 것이다
- 사용자는 폼에 값을 입력하고 전송했는데 입력한 값이 잘못되어 다시 폼에 입력해야 할 때 한개의 항목이 ㅇ아닌 입력한 모든 항목에 대해 잘못된 값이 존재하는지 알고싶을 것이다.
- 응용 서비스에서 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 익셉션을 발생시키면 나머지 항목에 대해서는 값을 검사하지 않게된다.
- 이렇게되면 나머지 항목에 대해서 값이 올바른지 여부를 알 수 없게되며 이는 사용자가 같은 폼에 값을 여러번 입력하게 만든다.
- 이러한 불편을 해소하기 위해서는 응용 서비스에 값을 전달하기 전에 표현 영역에서 검사하면 된다.
- 스프링과 같은 프레임워크는 값 검증을 위한 Validator 인터페이스를 별도로 제공하므로 인터페이스를 구현한 검증기를 따로 구현하면 코드를 간결하게 줄일 수 있다.

<br>

```java
@Controller
public class MemberController {

	@RequestMapping
	public String join(JoinRequest joinRequest, Errors errors) {
		new JoinRequestValidator().validate(joinRequest, errors);

		...
	}
}
```

<br>

- 이렇게 표현 영역에서 필수 값과 값의 형식만 검사하면 실질적으로 응용 서비스는 아이디 중복 여부와 같은 논리적인 오류만 검사하면 된다.
- 즉, 같은 값 검사를 표현 영역과 응용 서비스에서 중복적으로 할 필요가 없는 것이다.
- 때문에 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 분리할 수 있다.
    - 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증
    - 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류 검증

<br>

# 권한 검사

- 개발할 시스템마다 권한의 복잡도가 달라지며 단순한 시스템은 인증 여부만 검사하면 되는데 반해, 어떤 시스템은 관리자인지 여부에 따라 사용할 수 있는 기능이 달라지기도한다.
- 또, 역할마다 실행할 수 있는 기능이 달라지는 경우도 있으며 이런 다양한 상황을 충족하기 위해 스프링 시큐리티나 아파치 Shiro 같은 프레임워크는 유연하고 확장 가능한 구조를 가지고 있다.
- 보안 프레임워크에 대한 이해가 부족하면 프레임워크를 무턱대고 도입하는 것보다는 개발할 시스템에 맞는 권한 검사 기능을 구현하는 것이 유지보수에 유리할 수 있다.

<br>

## 영역에 따른 권한 검사 수행

- 표현 영역에서 할 수 있는 가장 기본적인 검사는 인증된 사용자인지 아닌지 여부를 검사하는 것이다.
- 대표적으로 회원 정보 변경이 이에 해당하며 회원 정보 변경과 관련된 URL은 인증된 사용자만 접근해야 한다.
- 회원 정보를 변경을 처리하는 URL에 대해 다음과 같이 접근 제어를 할 수 있다.
    - URL을 처리하는 컨트롤러에 웹 요청을 전달하기 전에 인증 여부를 검사해서 인증된 사용자의 요청만 컨트롤러에 전달한다.
    - 인증된 사용자가 아닌 경우 로그인 화면으로 리다이렉트 시킨다.
- 이러한 제어를 하기 좋은 위치가 서블릿 필터이며 이 곳에서 사용자의 인증 정보를 생성하고 검사하는 것이다.
- 스프링 시큐리티는 이와 유사한 방식으로 필터를 이용해서 인증 정보를 생성하고 웹 접근을 제어하게 된다.
- URL 만으로 접근 제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 검사를 수행해야하며 이는 곧 응용 서비스 코드에서 직접 권한 검사를 해야함을 의미하는 것은 아니다.
- 스프링 시큐리티는 AOP를 활용하여 애너테이션으로 서비스 메서드에 대한 권한 검사를 할 수 있는 기능을 제공한다.
- 도메인 단위로 권한 검사를 해야하는 경우는 구현이 다소 복잡해지는데 게시글의 삭제는 본인 또는 관리자만 가능한 경우를 고려해보자.
- 이 경우 게시글 작성자가 본인인지 관리자인지 확인하려면 게시글 애그리거트를 먼저 로딩해야한다.
- 즉, 응용 서비스 메서드 수준에서 권한 검사를 할 수 없기 때문에 직접 권한 검사 로직을 구현해야한다.

<br>

# 조회 전용 기능과 응용 서비스

- 서비스에서 조회 전용 기능을 사용하게 되면 서비스 코드가 다음과 같이 단순히 조회 전용 기능을 호출하는 것으로 끝나는 경우가 많다.

```java
public List<OrderView> getOrderList(String ordererId) {
	return orderViewDao.selectBoyOrderer(ordererId);	
}
```

<br>

- 서비스에서 수행하는 추가적인 로직이 없을 뿐더러 조회 전용 기능이기 떄문에 트랜잭션이 필요하지도 않다.
- 이러한 경우에는 굳이 서비스를 만들 필요없이 표현 영역에서 조회 전용 기능을 사용해도 무방하다.
- 응용 서비스가 존재해야한다는 강박관념을 가지면 표현 영역에서 응용 서비스 없이 조회 전용 기능이나 도메인 리포지터리에 접근하는 것이 이상하게 느껴질 수 있다.
- 하지만 응용 서비스가 사용자 요청 기능을 실행하는데 별다른 기여를하지 못한다면 굳이 서비스를 만들지 않아도 된다고 생각한다.
