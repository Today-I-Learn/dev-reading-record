# 11장. CQRS

<br>


## 단일 모델의 단점

- 주문 내역을 조회하기 위해서는 여러 애그리거트에서 데이터를 가져와야 한다.
    - 주문 도메인에서 주문 정보를 가져와야 하고
    - 상품 도메인에서 상품 이름을 가져와야하고
    - 회원 도메인에서 회원의 이름과 아이디를 가져와야 한다

<br>

### ID 참조 방식의 한계

- 조회 화면의 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트에서 데이터를 가져와야 할 경우 구현 방법을 고민해보아야 한다.
    - 3장의 ID를 이용한 애그리거트 참조 방식을 사용하면 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.
    - 즉, 한번의 SELECT 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없기 때문에 조회 속도에 문제가 생길 수 있다.

<br>

### 직접 참조 방식의 한계

- 애그리거트 간의 연관관계를 ID가 아닌 직접 참조하는 방식으로 설정하더라도 고민이 발생한다.
    - 조회 화면의 특성에 따라 직접 참조하는 애그리거트들도 즉시 로딩 또는 지연 로딩 방식으로 처리해야하는 경우가 생기기 때문이다.
    - RDBMS가 제공하는 전용 기능을 이용해서 조회 쿼리를 작성해야하는 경우에는 네이티브 쿼리를 사용해야 할 수도 있다.
    

<br>

### 구현의 복잡도를 낮추는 방법

- 결과적으로 이러한 고민이 발생하는 이유는 시스템의 상태를 변경할 떄와 조회할 때 단일 도메인 모델을 사용하기 때문이다.
    - 객체지향 도메인 모델 구현을 위한 ORM기법은 도메인 상태 변경 구현에는 적합하지만
    - 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하는데는 고민할 것들이 많아 구현을 복잡하게 만드는 원인이 된다.
- 이러한 구현의 복잡도를 낮추기 위한 간단한 방법은 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

<br>

## CQRS

- 시스템이 제공하는 기능을 크게 두 가지로 나누어 생각할 수 있다.
    - 상태를 변경하는 기능 (ex. 새로운 주문 생성, 배송지 정보 변경, 회원 정보 변경)
    - 상태 정보를 조회하는 기능 (ex. 주문 상세 내역 보기, 게시글 목록 보기, 판매 통계 데이터 보기)
- 도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다.
    - ex. 주문 취소 기능과 배송지 정보 변경 등의 기능은 한 개의 주문 애그리거트를 변경한다.
- 반면 조회기능은 한 애그리거트의 데이터를 조회할 수 있지만 둘 이상의 애그리거트에서 데이터를 조회할 수도 있다.
- 상태를 변경하는 범위와 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.
- 상태 변경 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 CQRS (Command Query Responsibility Segregation) 패턴은 이러한 문제를 쉽게 해결해준다.

<br>

### 복잡한 도메인에서의 조회 기능 구현

- 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터의 범위에 많은 차이가 발생하게 된다.
- 두 기능을 단일 모델로 처리할 경우 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해지는 문제가 발생한다.
    - 온라인 쇼핑에서 다양한 차원에서 주문 및 판매 통계를 조회하는 경우를 가정하자.
    - JPA 기반의 단일 도메인 모델을 사용하면 통계 값을 빠르게 조회하기 위해서 JPA와 관련된 다양한 성능 관련 기능을 모델에 적용해야한다.

<br>

### CQRS를 이용한 조회 기능 성능 최적화

- CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.
    - ex. 명령 모델은 객체지향에 기반해서 JPA를 사용해서 구현하고 조회 모델은 MyBatis를 사용해서 구현할 수 있다.
- 조회 모델에는 단순히 데이터를 읽어와 조회하는 기능이기 때문에 컨트롤러에서 DAO를 직접 실행하여 응용 서비스가 존재하지 않을 수 있다.
- 뿐만 아니라 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다.
    - ex. 명령 모델은 RDBMS를 사용하고 조회 모델은 Redis와 같은 인메모리 데이터베이스를 사용할 수 있다.
    - 두 저장소 사이의 데이터 동기화는 이벤트를 활용해서 처리할 수 있는데 명령 모델에서 상태를 변경하면 이벤트가 발생하고 해당 이벤트를 조회 모델에 전달해서 변경을 반영하면 된다.
- 서로 다른 저장소 사이에 동기화를 제공하는 방법은 다양하며(글로벌 트랜잭션 및 어느정도 딜레이를 허용하는 경우 비동기 적으로 처리) 상황에 따라 이를 적절하게 선택할 수 있다.

<br>

### 웹 서비스와 CQRS

- 일반적인 웹 서비스는 상태를 변경하는 요청보다 조회하는 요청이 많다. (파레토의 법칙에 따라서 약 2:8 정도)
    - ex. 온라인 쇼핑몰을 예로들면 주문 요청보다 카탈로그를 조회하고 상품의 상세 정보를 조회하는 요청이 비교할 수 없을 정도로 많다.
- 조회 성능을 높이기 위해서 쿼리 최적화, 읽기 전용 데이터베이스, 캐시 등의 방법을 이용할 수도 있는데 이를 위해 다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용한 것과 동일한 효과를 만든다.
- 이처럼 대규모 트래픽이 발생하는 웹 서비스는 단지 명시적으로 명령과 조회 모델을 구분하지 않을 뿐 알게모르게 CQRS를 적용하게 된다.
    - 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하여 모델이 복잡해지는 것을 방지할 수 있고 조회에 특화된 구현 기법을 쉽게 적용할 수 있다.

<br>

### CQRS의 장점

- CQRS를 적용할 때 얻을 수 있는 장점 중 하나는 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다는 것이다.
    - 복잡한 도메인은 상태 변경 로직이 복잡한데 이를 분리하면 조회 성능을 위한 코드가 명령 모델에 없기 때문에 도메인 로직을 구현하는데 집중할 수 있다.
- 조회 단위로 캐시를 적용하거나 조회에 특화된 쿼리를 마음대로 적용하는 등 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않기 떄문에 조회 성능 향상시키는데 유리하다.

<br>

### CQRS의 단점

- 조회 전용 모델을 만들기 위한 구현 코드 및 비용이 증가하게 된다.
    - 트래픽이 많지 않은 서비스라면 굳이 조회 전용 모델을 만들 이유가 없다.
- 경우에 따라서 다양하고 많은 구현 기술들을 도입해야 할 수 있다.
