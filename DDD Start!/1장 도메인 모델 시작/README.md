# 1장. 도메인 모델 시작 

<br>

## 1. 도메인

- 도메인은 소프트웨어로 해결하고자하는 문제의 영역이라고 할 수 있다.
    - ex. 온라인 서점
- 도메인은 다시 하위 도메인으로 나눌 수 있으며 하나의 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공한다.
    - ex. 온라인 서점에서 고객이 물건을 구매하면 하위 도메인인 주문, 결제, 배송 등의 기능이 엮여서 고객에게 주문한 상품을 전달하는 일련의 과정을 처리한다.
- 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야할 모든 기능을 구현하는 것은 아니며 기능을 제공하기 위해 외부 시스템을 이용할 수 있다.
    - ex. 온라인 서점 도메인에서 결제와 배송과 같은 하위 도메인은 외부 PG 회사나 물류 회사의 시스템을 이용할 수 있다.
- 도메인마다 고정된 하위 도메인이 존재하는 것은 아니기 때문에 하위 도메인을 어떻게 구성할지 여부는 상황에 따라서 달라지게 된다.

<br>

## 2. 도메인 모델

- 도메인 모델의 기본적인 정의는 특정 도메인을 개념적으로 표현한 것을 의미한다 즉, 도메인 자체를 이해하기 위한 개념 모델이다.
- 도메인 모델은 객체 기반의 클래스 다이어그램이나, 상태 전이 모델링을 이용한 상태 다이어그램과 같은 방법들을 이용해서 표현할 수 있다.
- 즉, 도메인 모델은 도메인을 이해하는데 도움이 된다면 표현 방식이 무엇인지는 중요하지 않는다.
- 이러한 도메인 모델들은 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.
- 개념적인 모델을 이용해서 바로 코드를 작성하는 것은 어렵기 때문에 구현 기술에 맞는 구현 모델이 따로 필요하다.
- 개념 모델과 구현 모델은 서로 다른 것이지만 구현 모델이 개념 모델을 최대한 따르게 할 수 있다.
    - ex. 객체 기반 모델을 이용해서 도메인을 표현한 경우 객체지향 언어를 이용해서 개념 모델에 가깝게 구현할 수 있다.

<img src='https://user-images.githubusercontent.com/54518332/129497883-716bde11-c14e-49ca-952a-3788e85c664f.png' width='70%'>

<br>

### 하위 도메인과 모델

- 도메인은 다수의 하위 도메인으로 구성되며 하위 도메인이 다루는 영역이 서로 다르기 때문에 같은 용어라도 도메인 마다 의미가 달라질 수 있다.
    - ex. 카탈로그 도메인의 상품이 상품 가격, 상세 내용을 담고있는 정보를 의미한다면 배송 도메인의 상품은 고객에게 실제 배송되는 물리적인 상품을 의미한다.
- 즉, 도메인에 따라서 용어의 의미가 결정되기 때문에 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안된다.
- 각각의 모델의 구성요소는 특정 도메인을 한정할 때 의미가 완전해지기 때문에 하위 도메인마다 별도의 모델을 만들어야 한다.

<br>

## 3. 도메인 모델 패턴

- 일반적인 애플리케이션 아키텍처는 표현 계층, 응용 계층, 도메인 계층, 인프라 계층으로 구성된다.
    - 표현 계층 : 클라이언트 요청을 처리하고 정보를 보여주는 계층으로 클라이언트는 유저 뿐만 아니라 외부 시스템도 클라이언트가 될 수 있다.
    - 응용 계층 : 사용자가 요청안 기능을 실행하는 계층으로 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다.
    - 도메인 계층 : 시스템이 제공할 도메인 규칙을 구현한다.
    - 인프라 계층 : 데이터베이스나 메세징 시스템과 같은 외부 시스템과의 연동을 처리한다.

<br>

### 주문 도메인 모델

- 주문 도메인의 경우 다음과 같은 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.
    - 출고 전에 배송지를 변경할 수 있다.
    - 주문 취소는 배송 전에만 할 수 있다.
- 도메인 모델 패턴은 이러한 도메인 규칙을 객체지향 기법으로 구현하는 것을 의미한다.
- 배송 변경지 가능 여부를 판단하는 핵심 규칙을 구현하는 코드를 주문이나 주문 상태 도메인 모델 안에 구현하게 되면 규칙이 바뀌거나 확장해야 될 때 다른 코드에 영향을 덜 주고 변경 내역을 쉽게 모델에 반영할 수 있다.

<br>

### 개념 모델과 구현 모델

- 개념 모델은 순수하게 문제를 분석한 결과물로 데이터베이스, 트랜잭션, 성능, 구현 기술 등과 같은 것들을 고려하지 않고 있기 때문에 실제 코드를 작성할 때 개념 모델을 있는 그대로 사용할 수 없다.
- 때문에 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거치게 된다.
- 개념 모델을 처음부터 완벽하게 도메인을 표현하는 모델로 만드는 것은 불가능에 가까우며 도메인 지식이 시간이 지나 새로운 통찰을 얻으면서 완전히 새로운 의미로 해석되는 경우도 존재한다.
- 떄문에 프로젝트 초기에 완벽한 도메인 모델을 만들더라도 결국 도메인에 대한 새로운 지식이 쌓이면서 모델을 보완하거나 수정하는 일이 발생하게 된다.
- 때문에 처음부터 완벽한 개념 모델을 만들기 보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야하고 이를 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.

<br>

## 4. 도메인 모델 도출

- 도메인에 대한 이해 없이 개발을 하는 것은 불가능하기 때문에 기획서, 사용 사례, 사용자 스토리와 같은 요구사항과 관련자와의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 코드를 작성하는 것이 가능하다.
- 즉, 어떠한 방법이나 도구를 선택하든지 간에 구현을 시작하기 위해서는 도메인에 대한 초기 모델이 필요하다.

<br>

### 도메인 모델링

- 도메인을 모델링 할 때 가장 기본이 되는 작업은 모델을 구성하는 핵심 구성 요소와 규칙을 찾는 것이다.
- 이러한 과정은 요구사항에서 출발하며 주문 도메인과 관련된 요구사항을 분석하면 다음과 같다.

<br>

#### 주문 도메인 요구사항

- 최소 한 종류 이상의 상품을 주문해야한다.
- 한 상품을 한 개 이상 주문할 수 있다.
- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 주문할 때 배송지 정보를 반드시 지정해야 한다.
- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- 출고를 하면 배송지 정보를 변경할 수 없다.
- 출고 전에 주문을 취소할 수 없다.
- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

<br>

#### 요구사항을 통해 기능을 도출하기

- 요구사항에서 알 수 있는 것은 다음과 같다.
    - 주문 상태를 출고 상태로 변경하기
    - 배송지 정보 변경하기
    - 주문 취소하기
    - 결제 완료로 변경하기

<br>

### 문서화

- 문서화를 하는 주된 이유는 지식을 공유하기 위함이다.
- 실제 구현은 코드를 보면 알 수 있지만 코드는 상세한 모든 내용을 다루고있기 때문에 코드를 이용해서 전체 소프트웨어를 분석하려면 많은 시간을 투자해야한다.
- 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는데 도움된다.
- 코드를 보면서 도메인을 깊게 이해하게 되기 때문에 코드 자체도 문서화의 대상이 된다.
- 도메인 지식이 잘 묻어나도록 코드를 작성하지 않으면 코드의 동작 과정은 해석할 수 있어도 도메인 ㅗ간점에서 왜 코드를 그렇게 작성했는지 이해하는데는 도움이 되지 않는다.
- 단순히 코드를 보기 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지며 문서로서 코드가 의미를 갖게 된다.

<br>

## 5. 엔티티와 벨류

- 도출한 모델은 크게 `Entity` 와 `Value` 로 구분할 수 있는데 이 둘을 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 둘의 차이를 명확하게 이해하는 것은 도메인을 구현하는데 있어 중요하다.

<br>

### 엔티티

- 엔티티의 가장 큰 특징은 식별자를 갖는다는 것이다.
- 주문에서 배송지의 주소가 바뀌거나 상태가 변하더라도 주문 번호가 바뀌지 않는 것처럼 엔티티의 식별자는 바뀌지 않는다.
- 엔티티를 생성하고 삭제할 때 까지 식별자는 유지된다.
- 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티의 식별자가 같으면 두 엔티티가 같다고 판단할 수 있다.
- 때문에 엔티티를 구현한 클래스는 식별자를 이용해서 `equals()` 와 `hashCode()` 를 구현할 수 있다.

<br>

#### 엔티티의 식별자 생성

- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라지지만 대부분 다음의 방식 중 한가지로 생성하게 된다.
- 특정 규칙에 따라서 생성 → 주문번호, 운송장번호, 카드 번호
- UUID
- 값을 직접 입력 → 회원의 아이디나 이메일
- 데이터베이스 시퀀스나 자동 증가 컬럼과 같은 일련번호를 사용

<br>

### 벨류 타입

- `Value` 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. 예를들어 받는 사람을 위한 `Value` 타입인 `Receiver` 를 다음과 같이 작성할 수 있다.

```java
public class Receiver {

	private String name;
	private String phoneNumber;

	public Receiver(String name, String phoneNumber) {
		this.name = name;
		this.phoneNumber = phoneNumber;
	}
}
```

<br>

- `ShoppingInfo` 의 각각의 필드인 `receiverName` , `receiverPhonenumber` 필드가 필드 이름을 통해서 받는 사람을 위한 데이터 라는 것을 유추할 수 있다면 `Receiver` 는 그 자체로 받는 사람을 의미한다.
- 즉, `Value` 타입을 통해서 개념적으로 완전한 하나를 잘 표현할 수 있다.
- `Value` 타입은 두 개 이상의 데이터를 하나로 묶는 경우 뿐만 아니라 의미를 명확하게 표현하기 위해 사용하는 경우도 존재한다.
- `OrderLine` 클래스의 `price` , `amounts` 는 돈을 의미하는데 돈을 의미하는 `Money` 타입을 만들어서 사용하면 코드를 이해하는데 도움이 된다.

```java
public class Money {

	private int value;

	public Money(int value) {
		this.value = value;
	}
}
```

<br>

- `Value` 타입을 사용할 때의 또 다른 장점은 `Value` 타입을 위한 기능을 추가로 작성할 수 있다는 것인데 `Money` 타입의 경우 돈 계산을 위한 기능을 추가할 수 있다.

<br>

#### 벨류 타입과 불변 객체

- `Value` 객체의 데이터를 변경할 떄는 기존의 데이터를 변경하는 것보다 변경된 데이터를 갖는 새로운 `Value` 객체를 생성하는 방식을 선호한다.
- 이러한 타입의 객체를 불변 타입이라고 하는데 `Value` 타입을 불변으로 구현하는 가장 중요한 이유는 안전한 코드를 작성할 수 있기 때문이다.
- 즉, 동시에 여러 쓰레드가 `Value` 타입에 접근해서 데이터를 변경하는 경우나 의도하지 않은 방법으로 값을 갱신하는 것과 같은 상황에서 불변 객체로 설계할 경우 이로 인한 문제를 사전에 예방할 수 있다.

<br>

### 엔티티 식별자와 벨류 타입

- `Entity` 타입을 비교할 때 식별자를 사용한다면 `Value` 타입을 비교할 때는 모든 속성이 같은지를 비교해야한다.
- 엔티티의 식별자의 실제 데이터는 카드 번호나 이메일 주소와 같이 문자열로 구성된 경우가 많다.
- `Money` 가 단순한 숫자가 아닌 도메인의 돈을 의미하는 것 처럼 식별자는 단순 문자열이 아닌 도메인에서 특별한 의미를 지니는 경우가 많기 때문에 식별자를 위한 `Value` 타입을 사용해서 의미가 잘 들어나도록 할 수 있다.

<br>

### DTO의 접근자와 수정자 메서드

- DTO는 Data Transfer Object의 약자로 프레젠테이션 계층과 도메인 계층이 데이터를 서로 주고 받을 때 사용하는 일종의 구조체이다.
- 이전에는 요청 파라미터나 데이터베이스 컬럼의 값을 설정할 때 `setter` 메서드를 필요로 했기 떄문에 구현 기술을 적용하려면 `getter` , `setter` 메서드를 DTO에 정의해야했다.
- DTO가 도메인 로직을 담고있지는 않기 때문에 `getter` , `setter` 을 제공해도 도메인 객체의 데이터 일관성에 영향을 줄 가능성은 높지 않다.
- 최근 프레임워크는 `setter` 메서드가 아닌 `private` 필드에 직접 값을 할당할 수 있는 기능을 제공하기 때문에 `setter` 를 반드시 제공하지 않아도된다.
- 위의 기능을 활용하면 DTO도 불변 객체로 설계할 수 있고 불변 객체의 장점을 DTO까지 확장할 수 있게 된다.

<br>

## 6. 도메인 용어

- 도메인 용어는 매우 중요하며 이를 코드에 반영하지 않으면 개발자에게 코드의 의미를 해석해야하는 부담감을 주게 된다.
- 때문에 도메인 용어를 코드에 최대한 반영하면 코드를 도메인 용어로 해석하거나 도메인 용어를 코드로 해석하는 과정이 줄어들고 코드만 보고도 의미를 명확하게 이해할 수 있다.
- 즉, 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 줄여준다.
